\documentclass[10pt]{article}
\usepackage{amsmath, listings, amsthm, amssymb, latexsym, proof, syntax, stmaryrd, tikz-cd}
\usepackage[T1]{fontenc}
\usepackage{scrlayer-scrpage,hyperref}

\input{defs.tex}

\begin{document}

\section{Introduction}

In this document, we give a translation from fun-SuSLik to SuSLik. First, we define the syntax and
operational semantics of the two languages (Sections~\ref{sec:FSDef} and~\ref{sec:SuSLikDef}).
Then, we give definitions of semantic equivalence in terms of these
operational semantics (Sections~\ref{sec:FSEquiv} and~\ref{sec:SuSLikEquiv}). The translation from fun-SuSLik is represented as a denotational semantics
that denotes a fun-SuSLik expression as a SuSLik goal (Section~\ref{sec:Translation}). Finally, we show that this denotational
semantics preserves semantic equivalence by proving adequacy and full abstraction (Section~\ref{sec:TransSoundness}).
\\


% In this document, we describe the semantics of fun-SuSLik and translate them
% into SuSLik's semantics. Then, we translate both fun-SuSLik and SuSLik into a
% category of abstract stores and mappings between of abstract stores. An abstract store is a
% mapping from locations to values of a base type or a tuple of base types (here, the base types are \verb|int| and \verb|bool|).
% By ``location,'' we mean an abstract location: it is not represented as a number and therefore
% you cannot perform pointer arithmetic on it. We do this to avoid these extra details, which
% are not relevant to proving semantics preservation.
%
% An overview of this is given in the diagram below.
% \\
%
% \begin{tikzcd}
%   \text{fun-SuSLik} \arrow[d, "\Gsem{\cdot}"] \arrow[r, swap, "\sigma_{\mathcal{FS}}"]
%   &
%   \text{Abstract stores} \arrow[dddl, "id"]
%   \\
%   \text{Ghost approximation} \arrow[d, "\Ssem{\cdot}"]
%   \\
%   \text{SuSLik} \arrow[d, "\sigma_{\mathcal{S}}"]
%   \\
%   \text{Abstract stores}
%   % \\
%   % \text{Abstract stores}
% \end{tikzcd}
%
% ~\\
% \noindent
% We show that the translation of fun-SuSLik into SuSLik is semantics preserving by proving that this diagram commutes.
% \\
%
% \noindent
% The four categories involved are:
%
% \begin{itemize}
%   \item The fun-SuSLik category of fun-SuSLik values and fun-SuSLik functions
%   \item The ghost approximation category of SuSLik ghost values and functions between them. These ghost values are the values which are manipulated in the pure part of a SuSLik assertion
%   \item The SuSLik category of heaps and SuSLik functions
%   \item The abstract stores category of abstract stores and mappings between abstract stores
% \end{itemize}
%
%

\section{fun-SuSLik Language Definition}
\label{sec:FSDef}
\subsection{Syntax}

\begin{grammar}
  <I> ::= ... | -1 | 0 | 1 | ...

  <B> ::= \ttt{True} | \ttt{False}

  <D> ::= \ttt{x :} <T>; x <P> \ttt{:=} <e>;

  <P> ::= $\varepsilon$ | x <P>

  <e> ::= <e>$_0$ | <e> <e>$_0$

  <e$_0$> ::= <I> | <B> | \ttt{unit} | <L> | <C> | \letbnd\; x \ttt{:=} <e> \inexpr\; <e> | ( <e> )

  <L> ::= $\lambda x \ra$ <e>

  <C> ::= \head\; | \tail\; | \cons\; | \nil\; | \foldr\; | \pair\; | \fst\; | \snd\; | \ite\; | \lesseq\; | \eq\; | \add\; | \sub

  <T> ::= \ttt{Int} | \ttt{Bool} | \ttt{Unit} | <T> $\ra$ <T> | \ttt{List} <T> | \ttt{Pair} <T> <T> | ( <T> )

  <$\Gamma$> ::= $\cdot$ | x : <T>, $\Gamma$
\end{grammar}

\subsection{Typing Judgment}

\[
  \begin{array}{c}[t]
    \infer{\Gamma \vdash x : T}{(x : T) \in \Gamma}
    ~~~
    \infer{\vdash i : \ttt{Int}}{i \in \mathbb{Z}}
    \\\\
    \infer{\vdash \ttt{unit} : \ttt{Unit}}{}
    ~~~
    \infer{\vdash \ttt{True} : \ttt{Bool}}{}
    ~~~
    \infer{\vdash \ttt{False} : \ttt{Bool}}{}
    \\\\
    \infer{\Gamma \vdash t_0\; t_1 : T'}{\Gamma \vdash t_0 : T \ra T' & \Gamma \vdash t_1 : T}
    \\\\
    \infer{\Gamma \vdash \lambda x \ra t : T \ra T'}{x : T, \Gamma \vdash t : T'}
    \\\\
    \infer{\Gamma \vdash \letbnd\; x\; \ttt{:=}\; e\; \inexpr\; e' : T'}{\Gamma \vdash e : T & x : T, \Gamma \vdash e' : T'}
    \\\\
    \infer{\vdash \ttt{nil} : \List\; T}{}
    ~~~
    \infer{\vdash \ttt{cons} : T \ra \List\; T \ra \List\; T}{}
    \\\\
    \infer{\vdash \ttt{head} : \List\; T \ra T}{}
    ~~~
    \infer{\vdash \ttt{tail} : \List\; T \ra \List\; T}{}
    \\\\
    \infer{\vdash \ttt{foldr} : (T \ra T' \ra T') \ra T' \ra \List\; T \ra T'}{}
    \\\\
    \infer{\vdash \ttt{pair} : T \ra T' \ra \tyPair\; T\; T'}{}
    ~~~
    \infer{\vdash \ttt{fst} : \tyPair\; T\; T' \ra T}{}
    ~~~
    \infer{\vdash \ttt{snd} : \tyPair\; T\; T' \ra T'}{}
    \\\\
    \infer{\vdash \ttt{ifThenElse} : \Bool \ra T \ra T \ra T}{}
    \\\\
    \infer{\vdash \ttt{le} : \Int \ra \Int \ra \Bool}{}
    ~~~
    \infer{\vdash \ttt{eq} : \Int \ra \Int \ra \Bool}{}
    \\\\
    \infer{\vdash \ttt{add} : \Int \ra \Int \ra \Int}{}
    ~~~
    \infer{\vdash \ttt{sub} : \Int \ra \Int \ra \Int}{}
  \end{array}
\]

\subsection{Small-Step Operational Semantics}

First, the ``value'' judgment val (as in Harper's Practical Foundations for Programming Languages, Sec. 19.2):

\[
  \begin{array}{cc}
    \infer{i \val}{i \in \mathbb{Z}}
    ~~~
    \infer{\unit \val}{}
    ~~~
    \infer{\True \val}{}
    ~~~
    \infer{\False \val}{}
    ~~~
    \infer{\nil \val}{}
    \\\\
    \infer{\cons\; e_1\; e_2 \val}{e_1 \val & e_2 \val}
    ~~~
    \infer{\pair\; e_1\; e_2 \val}{e_1 \val & e_2 \val}
    ~~~
    \infer{\lambda x \ra e \val}{}
  \end{array}
\]

\noindent
Now the small-step reduction relation $\reduces$\\
\textbf{TODO: See if this can be simplified by using evaluation contexts}

\[
  \begin{array}{cc}
    \labinfer[App-1]{e_1\; e_2 \reduces e_1\; e_2'}{e_2 \reduces e_2'}
    ~~~
    \labinfer[App-2]{e_1\; e_2 \reduces e_1'\; e_2}{e_1 \reduces e_1' & e_2 \val}
    ~~~
    \labinfer[App-$\lambda$]{(\lambda x \ra e)\; e_2 \reduces e[x\mapsto e_2]}{e_2 \val}
    \\\\
    \labinfer[Let-Bnd]{\letbnd\; x\; \ttt{:=}\; e_1\; \inexpr\; e_2 \reduces \letbnd\; x\; \ttt{:=}\; e_1'\; \inexpr\; e_2}
       {e_1 \reduces e_1'}
    \\\\
    \labinfer[Let-Subst]{\letbnd\; x\; \ttt{:=}\; e_1\; \inexpr\; e_2 \reduces e_2[x\mapsto e_1]}{e_1 \val}
    \\\\
    \labinfer[Cons-1]{\cons\; e_1\; e_2 \reduces \cons\; e_1'\; e_2}{e_1 \reduces e_2}
    ~~~
    \labinfer[Cons-2]{\cons\; e_1\; e_2 \reduces \cons\; e_1\; e_2'}{e_1 \val & e_2 \reduces e_2'}
    \\\\
    \labinfer[Head-1]{\head\; e \reduces \head\; e'}{e \reduces e'}
    ~~~
    \labinfer[Tail-1]{\tail\; e \reduces \tail\; e'}{e \reduces e'}
    \\\\
    \labinfer[Head-Cons]{\head\; (\cons\; e_1\; e_2) \reduces e_1}{\cons\; e_1\; e_2 \val}
    ~~~
    \labinfer[Tail-Cons]{\tail\; (\cons\; e_1\; e_2) \reduces e_2}{\cons\; e_1\; e_2 \val}
    \\\\
    \labinfer[Pair-1]{\pair\; e_1\; e_2 \reduces \pair\; e_1'\; e_2}{e_1 \reduces e_1}
    ~~~~
    \labinfer[Pair-2]{\pair\; e_1\; e_2 \reduces \pair\; e_1\; e_2'}{e_1 \val & e_2 \reduces e_2'}
    \\\\
    \labinfer[Foldr-1]{\foldr\; f\; e_0\; e \reduces \foldr\; f'\; e_0\; e}{f \reduces f'}
    ~~~
    \labinfer[Foldr-2]{\foldr\; f\; e_0\; e \reduces \foldr\; f\; e_0'\; e}{f \val & e_0 \reduces e_0'}
    \\\\
    \labinfer[Foldr-3]{\foldr\; f\; e_0\; e \reduces \foldr\; f\; e_0\; e'}{f \val & e_0 \val & e \reduces e'}
    \\\\
    \labinfer[Foldr-Cons]{\foldr\; f\; e_0\; (\cons\; e_1\; e_2) \reduces f\; e_1\; (\foldr\; f\; e_0\; e_2)}{f \val & e_0 \val & \cons\; e_1\; e_2 \val}
    % \\\\
    % % \infer{\ttt{scanr f z $e$} \reduces \ttt{cons e$'$ (f x
    \\\\
    \labinfer[Fst-1]{\fst\; e \reduces \fst\; e'}{e \reduces e'}
    ~~~
    \labinfer[Snd-1]{\snd\; e \reduces \snd\; e'}{e \reduces e'}
    \\\\
    \labinfer[Fst-Pair]{\fst\; (\pair\; e_1\; e_2) \reduces e_1}{\pair\; e_1\; e_2 \val}
    ~~~
    \labinfer[Snd-Pair]{\snd\; (\pair\; e_1\; e_2) \reduces e_2}{\pair\; e_1\; e_2 \val}
    \\\\
    \labinfer[IfThenElse-1]{\ite\; b\; e_1\; e_2 \reduces \ite\; b'\; e_1\; e_2}{b \reduces b'}
    \\\\
    \labinfer[IfThenElse-True]{\ite\; \True\; e_1\; e_2 \reduces e_1}{}
    ~~~
    \labinfer[IfThenElse-False]{\ite\; \False\; e_1\; e_2 \reduces e_2}{}
    \\\\
    \labinfer[Le-1]{\lesseq\; e_1\; e_2 \reduces \lesseq\; e_1'\; e_2}{e_1 \reduces e_1'}
    ~~~
    \labinfer[Le-2]{\lesseq\; e_1\; e_2 \reduces \lesseq\; e_1\; e_2'}{e_1 \val & e_2 \reduces e_2'}
    \\\\
    \labinfer[Le-<]{\lesseq\; e_1\; e_2 \reduces \True}{e_1 \val & e_2 \val & e_1 < e_2}
    ~~~
    \labinfer[Le-=]{\lesseq\; e\; e \reduces \True}{e \val}
    \\\\
    \labinfer[Le-False]{\lesseq\; e_1\; e_2 \reduces \False}{e_1 \val & e_2 \val & e_1 > e_2}
    \\\\
    \labinfer[Eq-1]{\eq\; e_1\; e_2 \reduces \eq\; e_1'\; e_2}{e_1 \reduces e_1'}
    ~~~
    \labinfer[Eq-1]{\eq\; e_1\; e_2 \reduces \eq\; e_1\; e_2'}{e_1 \val & e_2 \reduces e_2'}
    \\\\
    \labinfer[Eq-True]{\eq\; e\; e \reduces \True}{e \val}
    ~~~
    \labinfer[Eq-False]{\eq\; e_1\; e_2 \reduces \False}{e_1 \val & e_2 \val & e_1 \neq e_2}
    \\\\
    \labinfer[Add-1]{\add\; e_1\; e_2 \reduces \add\; e_1'\; e_2}{e_1 \reduces e_1'}
    ~~~
    \labinfer[Add-2]{\add\; e_1\; e_2 \reduces \add\; e_1\; e_2'}{e_1 \val & e_2 \reduces e_2'}
    ~~~
    \labinfer[Add-Apply]{\add\; e_1\; e_2 \reduces v}{e_1 \val & e_2 \val & v = e_1 + e_2}

  \end{array}
\]

\noindent
Let $\reducestr$ be the transitive, reflexive closure of $\reduces$.

\begin{theorem}[Progress]
  $\forall e.\; e \val \lor (\exists e'.\; e \reduces e')$
\end{theorem}

\begin{theorem}[Preservation]
  \text{If} $e : T$ \text{and} $e \reduces e'$ \text{then} $e' : T$
\end{theorem}

\begin{theorem}[Uniqueness of Normal Forms]
  \text{If} $e : T$, $v \val$, $v' \val$, $e \reducestr v$ \text{and} $e \reducestr v'$ \text{then} $v = v'$
\end{theorem}

\subsection{Equivalence Relation}
\label{sec:FSEquiv}
We now define equivalence of fun-SuSLik programs.

\begin{definition}[Termination]
  $e$ \text{is \textnormal{terminating} iff} $\exists v.\; v \val \land e \reducestr v$.\\
  $e$ \text{is \textnormal{nonterminating} iff it is not terminating}
\end{definition}

\begin{definition}[fun-SuSLik Equivalence]
  If $e$ and $e'$ are both nonterminating, then $e \approx_F e'$.\\
  If $e$ and $e'$ are both terminating, then $e \approx_F e'$ iff $\exists v. e \reducestr v \land e' \reducestr v$\\
  Otherwise, $e$ and $e'$ are not equivalent and we write $e \not\approx_F e'$
\end{definition}

\section{SuSLik Specification Language}
\label{sec:SuSLikDef}

We define the syntax of the SuSLik specification language and then an equivalence of SuSLik synthesis goals.
The following syntax definition is adapted from \textit{Cyclic Program Synthesis, 2021}:
\\
\[ \small
  \begin{array}[t]{ l l }
    \text{Variable} &x, y\;\; \text{Alpha-numeric identifiers $\in$ PV}\\
    \text{Size, offset} &n, \iota\;\; \text{Non-negative integers}\\
    \text{Expression} &e ::= 0\; \alt \true \alt x \alt e = e \alt e \land e \alt \neg e \alt d\\
    \text{$\mathcal{T}$-expr.} &d ::= n \alt x \alt d + d \alt n \cdot d \alt {} \alt {d} \alt \cdots\\
    \text{Command} &c ::= \letbnd\; \ttt{x = *(x + }\iota\ttt{)} \alt \ttt{*(x + }\iota\ttt{) = e} \alt\newline
      \letbnd\; \ttt{x = malloc(n)} \alt \ttt{free(x)} \alt \ttt{error}\newline
      \alt \ttt{f(}\overline{e_i}\ttt{)}\\
    \text{Program} &\Pi ::= \overline{f(\overline{x_i})\; \{\; c\; \}\; ;}\; c\\

    \text{Logical variable} &\nu, \omega\\
    \text{Cardinality variable} &\alpha\\
    \text{$\mathcal{T}$-term} &\kappa ::= \nu \alt e \alt \cdots\\
    \text{Pure logic term} &\phi, \psi, \chi ::= \kappa \alt \phi = \phi \alt \phi \land \phi \alt \neg \phi\\
    \text{Symbolic heap} &P, Q, R ::= \ttt{emp} \alt \mbox{$\langle e, \iota \rangle \mapsto e \alt [e, \iota]$} \alt p^{\alpha}(\overline{\phi_i})
      \alt \mbox{$P * Q$}\\
    \text{Heap predicate} &\mathcal{D} ::= p^{\alpha}(\overline{x_i}) : \overline{e_j \Ra \exists \overline{y}.\{\chi_j;\;R_j\}}\\
    \text{Assertion} &\mathcal{P},\mathcal{Q} ::= \{\phi; P\}\\
    \text{Environment} &\Gamma ::= \forall\overline{x_i}.\exists\overline{y_j}.\\
    \text{Context} &\Sigma ::= \overline{\mathcal{D}}\\
    \text{Model} &\mathcal{M} ::= \langle h, s \rangle\\
    \text{Stack} &s : \text{PV} \rightharpoonup \text{Val}\\
    \text{Heap} &h : \text{Loc} \rightharpoonup \text{Val}\\
    \text{Synthesis goal} &\mathcal{G} ::= P \leadsto Q
  \end{array}
\]

\subsection{Equivalence Relation}
\label{sec:SuSLikEquiv}

\begin{definition}[Synthesizability]
  We say a goal $\mathcal{G}$ is \textnormal{synthesizable} iff $\exists c. (\vdash \mathcal{G}\synth c)$
\end{definition}

\begin{definition}[SuSLik Command Equivalence]
  Given a context of inductive predicates $\Sigma$ and SuSLik commands $c$ and $c'$, $\Sigma \vdash c \approx_\mathcal{C} c'$ iff
    $\forall \mathcal{M}. \exists \mathcal{M'}.
      ((c, \mathcal{M}) \BigStep \mathcal{M'})
      \land
      ((c', \mathcal{M}) \BigStep \mathcal{M'})$
\end{definition}

\begin{definition}[SuSLik Goal Equivalence]
  Given a context of inductive predicates $\Sigma$ and synthesizable SuSLik goals $\mathcal{G}$ and $\mathcal{G}'$, $\Sigma \vdash \mathcal{G} \approx_{\mathcal{S}} \mathcal{G}'$ iff
    $(\forall c\; c'. ((\Sigma \vdash \mathcal{G} | c) \land (\Sigma \vdash \mathcal{G}' | c')) \implies (\Sigma \vdash c \approx_{\mathcal{C}} c')$
\end{definition}

\section{Translation of fun-SuSLik into SuSLik}
\label{sec:Translation}

We give a denotational semantics for fun-SuSLik, where the denotations are SuSLik goals, with
the denotation function $\sem{\blank} : \ttt{e} \ra (\Sigma \times \mathcal{G})$.
This translation is shown to preserve equivalence in two steps (Section~\ref{sec:TransSoundness}):

\begin{itemize}
  \item Equivalent fun-SuSLik expressions are mapped to equivalent SuSLik goals. This amounts to proving
    \textit{full abstraction} for $\sem{\blank}$.
  \item Non-equivalent fun-SuSLik expressions are mapped to non-equivalent SuSLik goals.
    This is accomplished by proving $\sem{\blank}$ is \textit{adequate}.
\end{itemize}

\subsection{Denotation by Inductive Predicates}

Some fun-SuSLik constructs will translate to inductive predicates. This is translation is
given by $\Isem{\blank} : \ttt{e} \ra (\ttt{I} \times \ttt{Name})$. This function produces both
the inductive predicate and its name. Its name is determined by the expression. This
name is unique as the inductive predicate is lambda lifted; that is, all captured variables
are turned into arguments to the inductive predicate.

% \subsection{Denotation With Environments}
%
% A denotation function $\Esem{\cdot} : \ttt{e} \ra \mathbb{N} \ra \ttt{SP} \times \mathbb{N}$ is defined using
% elements of $\mathbb{N}$ as a source of fresh variable names. We take $\fresh : \mathbb{N} \ra \Name \times \mathbb{N}$ as a function
% which will generate a fresh variable name together with an updated environment.
%
% We use the convention that the result value of $\Esem{e}(n)$ will be stored in $n$.
%
% % For convenience, we define the following operator for applying a function in an environment to a value in an environment:
% %
% % \begin{definition}[Environment Bind]
% %   $\ttt{envApply} : (\ttt{e} \ra $
% % \end{definition}
%
% \begin{definition}[Denotation Function for fun-SuSLik]
%   $\sem{e} = proj_1(\Esem{e}(0))$
% \end{definition}
%
% \noindent
% We define $\Esem{\cdot}$ as follows.
%


\subsection{Soundness}
\label{sec:TransSoundness}

% \begin{definition}[$\alpha$-Equivalence of Contexts]
%   If $\Sigma$ and $\Sigma'$ are equal up to renaming, then we write $\Sigma \approx_{\alpha} \Sigma'$
% \end{definition}

\begin{theorem}[Context Preservation]
  $e \approx_F e' \implies \first(\sem{e}) = \first(\sem{e'})$
\end{theorem}

\begin{theorem}[Full Abstraction]
  If $e$ and $e'$ are fun-SuSLik expressions and $e \approx_F e'$ and $\Sigma = \first(\sem{e}) = \first(\sem{e'})$,
  then $\Sigma \vdash \second(\sem{e}) \approx_{\mathcal{S}} \second(\sem{e'})$
\end{theorem}

\begin{theorem}[Adequacy]
  If $e$ and $e'$ are fun-SuSLik expressions and $e \not\approx_F e'$ and $e \approx_F e'$ and $\Sigma = \first(\sem{e}) = \first(\sem{e'})$,
  then $\Sigma \vdash \sem{e} \not\approx_{\mathcal{S}} \sem{e'}$
\end{theorem}

\subsection{Example: \ttt{foldr add 0 xs}}

% Two cases, \nil\; and \cons:
%
% \begin{itemize}
%   \item \nil
%     \\
%     \[
%       \sem{\ttt{foldr add 0 nil}} = 
%     \]
% \end{itemize}

\end{document}


