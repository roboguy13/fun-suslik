\documentclass[10pt]{article}
\usepackage{amsmath, listings, amsthm, amssymb, proof, syntax, stmaryrd}
\usepackage[T1]{fontenc}
\usepackage{scrlayer-scrpage}

\newtheorem{theorem}{Theorem}

\renewcommand{\syntleft}{}
\renewcommand{\syntright}{}

\newcommand{\infers}{\ensuremath{\Rightarrow}}
\newcommand{\checks}{\ensuremath{\Leftarrow}}

\newcommand{\ttt}[1]{\texttt{#1}}
\newcommand{\ra}{\ensuremath{\rightarrow}}
\newcommand{\Ra}{\ensuremath{\Rightarrow}}

\newcommand{\reduces}{\ensuremath{\longmapsto}}
\newcommand{\reducestr}{\ensuremath{\longmapsto^{*}}}

\newcommand{\val}{\textnormal{ val}}

\newcommand{\True}{\ttt{True}}
\newcommand{\False}{\ttt{False}}
\newcommand{\head}{\ttt{head}}
\newcommand{\tail}{\ttt{tail}}
\newcommand{\cons}{\ttt{cons}}
\newcommand{\nil}{\ttt{nil}}
\newcommand{\unit}{\ttt{unit}}
\newcommand{\foldr}{\ttt{foldr}}
% \newcommand{\scanr}{\ttt{scanr}}
\newcommand{\pair}{\ttt{pair}}
\newcommand{\fst}{\ttt{fst}}
\newcommand{\snd}{\ttt{snd}}
\newcommand{\ite}{\ttt{if}}

\newcommand{\Int}{\ttt{Int}}
\newcommand{\Bool}{\ttt{Bool}}
\newcommand{\tyUnit}{\ttt{Unit}}
\newcommand{\tyPair}{\ttt{Pair}}
\newcommand{\List}{\ttt{List}}
\newcommand{\letbnd}{\ttt{let}}
\newcommand{\inexpr}{\ttt{in}}
\newcommand{\defeq}{\ttt{:=}}

\newcommand{\lesseq}{\ttt{le}}
\newcommand{\eq}{\ttt{eq}}

\newcommand{\labinfer} [3] [] {\infer[{\small\textsc{#1}}]{#2}{#3}}

\newcommand{\sem} [1] {\llbracket#1\rrbracket}
\newcommand{\Gsem} [1] {\mathcal{G}\sem{#1}}
\newcommand{\Ssem} [1] {\mathcal{S}\sem{#1}}
\newcommand{\Gapprox} {\approx}
\newcommand{\Atoms} {\mathcal{A}}

\begin{document}

\section{Syntax}

\begin{grammar}
  <I> ::= ... | -1 | 0 | 1 | ...

  <B> ::= \ttt{True} | \ttt{False}

  <D> ::= \ttt{x :} <T>; x <P> \ttt{:=} <e>;

  <P> ::= $\varepsilon$ | x <P>

  <e> ::= <e>$_0$ | <e> <e>$_0$

  <e$_0$> ::= <I> | <B> | \ttt{unit} | <L> | <C> | \letbnd\; x \ttt{:=} <e> \inexpr\; <e> | ( <e> )

  <L> ::= $\lambda x \ra$ <e>

  <C> ::= \head\; | \tail\; | \cons\; | \nil\; | \foldr\; | \pair\; | \fst\; | \snd\; | \ite\; | \lesseq\; | \eq

  <T> ::= \ttt{Int} | \ttt{Bool} | \ttt{Unit} | <T> $\ra$ <T> | \ttt{List} <T> | \ttt{Pair} <T> <T> | ( <T> )

  <$\Gamma$> ::= $\cdot$ | x : <T>, $\Gamma$
\end{grammar}

\section{Typing Judgment}

\[
  \begin{array}{cc}
    \infer{\Gamma \vdash x : T}{(x : T) \in \Gamma}
    ~~~
    \infer{\vdash i : \ttt{Int}}{i \in \mathbb{Z}}
    \\\\
    \infer{\vdash \ttt{unit} : \ttt{Unit}}{}
    ~~~
    \infer{\vdash \ttt{True} : \ttt{Bool}}{}
    ~~~
    \infer{\vdash \ttt{False} : \ttt{Bool}}{}
    \\\\
    \infer{\Gamma \vdash t_0\; t_1 : T'}{\Gamma \vdash t_0 : T \ra T' & \Gamma \vdash t_1 : T}
    \\\\
    \infer{\Gamma \vdash \lambda x \ra t : T \ra T'}{x : T, \Gamma \vdash t : T'}
    \\\\
    \infer{\Gamma \vdash \letbnd\; x\; \ttt{:=}\; e\; \inexpr\; e' : T'}{\Gamma \vdash e : T & x : T, \Gamma \vdash e' : T'}
    \\\\
    \infer{\vdash \ttt{nil} : \List\; T}{}
    ~~~
    \infer{\vdash \ttt{cons} : T \ra \List\; T \ra \List\; T}{}
    \\\\
    \infer{\vdash \ttt{head} : \List\; T \ra T}{}
    ~~~
    \infer{\vdash \ttt{tail} : \List\; T \ra \List\; T}{}
    \\\\
    \infer{\vdash \ttt{foldr} : (T \ra T' \ra T') \ra T' \ra \List\; T \ra T'}{}
    \\\\
    \infer{\vdash \ttt{pair} : T \ra T' \ra \tyPair\; T\; T'}{}
    ~~~
    \infer{\vdash \ttt{fst} : \tyPair\; T\; T' \ra T}{}
    ~~~
    \infer{\vdash \ttt{snd} : \tyPair\; T\; T' \ra T'}{}
    \\\\
    \infer{\vdash \ttt{ifThenElse} : \Bool \ra T \ra T \ra T}{}
    \\\\
    \infer{\vdash \ttt{le} : \Int \ra \Int \ra \Bool}{}
    ~~~
    \infer{\vdash \ttt{eq} : \Int \ra \Int \ra \Bool}{}
  \end{array}
\]

\section{Small-Step Operational Semantics}

First, the ``value'' judgment val (as in Harper's Practical Foundations for Programming Languages, Sec. 19.2):

\[
  \begin{array}{cc}
    \infer{i \val}{i \in \mathbb{Z}}
    ~~~
    \infer{\unit \val}{}
    ~~~
    \infer{\True \val}{}
    ~~~
    \infer{\False \val}{}
    ~~~
    \infer{\nil \val}{}
    \\\\
    \infer{\cons\; e_1\; e_2 \val}{e_1 \val & e_2 \val}
    ~~~
    \infer{\pair\; e_1\; e_2 \val}{e_1 \val & e_2 \val}
    ~~~
    \infer{\lambda x \ra e \val}{}
  \end{array}
\]

\noindent
Now the small-step reduction relation $\reduces$


\[
  \begin{array}{cc}
    \labinfer[App-1]{e_1\; e_2 \reduces e_1\; e_2'}{e_2 \reduces e_2'}
    ~~~
    \labinfer[App-2]{e_1\; e_2 \reduces e_1'\; e_2}{e_1 \reduces e_1' & e_2 \val}
    ~~~
    \labinfer[App-$\lambda$]{(\lambda x \ra e)\; e_2 \reduces e[x\mapsto e_2]}{e_2 \val}
    \\\\
    \labinfer[Let-Bnd]{\letbnd\; x\; \ttt{:=}\; e_1\; \inexpr\; e_2 \reduces \letbnd\; x\; \ttt{:=}\; e_1'\; \inexpr\; e_2}
       {e_1 \reduces e_1'}
    \\\\
    \labinfer[Let-Subst]{\letbnd\; x\; \ttt{:=}\; e_1\; \inexpr\; e_2 \reduces e_2[x\mapsto e_1]}{e_1 \val}
    \\\\
    \labinfer[Cons-1]{\cons\; e_1\; e_2 \reduces \cons\; e_1'\; e_2}{e_1 \reduces e_2}
    ~~~
    \labinfer[Cons-2]{\cons\; e_1\; e_2 \reduces \cons\; e_1\; e_2'}{e_1 \val & e_2 \reduces e_2'}
    \\\\
    \labinfer[Head-1]{\head\; e \reduces \head\; e'}{e \reduces e'}
    ~~~
    \labinfer[Tail-1]{\tail\; e \reduces \tail\; e'}{e \reduces e'}
    \\\\
    \labinfer[Head-Cons]{\head\; (\cons\; e_1\; e_2) \reduces e_1}{\cons\; e_1\; e_2 \val}
    ~~~
    \labinfer[Tail-Cons]{\tail\; (\cons\; e_1\; e_2) \reduces e_2}{\cons\; e_1\; e_2 \val}
    \\\\
    \labinfer[Pair-1]{\pair\; e_1\; e_2 \reduces \pair\; e_1'\; e_2}{e_1 \reduces e_1}
    ~~~~
    \labinfer[Pair-2]{\pair\; e_1\; e_2 \reduces \pair\; e_1\; e_2'}{e_1 \val & e_2 \reduces e_2'}
    \\\\
    \labinfer[Foldr-1]{\foldr\; f\; e_0\; e \reduces \foldr\; f'\; e_0\; e}{f \reduces f'}
    ~~~
    \labinfer[Foldr-2]{\foldr\; f\; e_0\; e \reduces \foldr\; f\; e_0'\; e}{f \val & e_0 \reduces e_0'}
    \\\\
    \labinfer[Foldr-3]{\foldr\; f\; e_0\; e \reduces \foldr\; f\; e_0\; e'}{f \val & e_0 \val & e \reduces e'}
    \\\\
    \labinfer[Foldr-Cons]{\foldr\; f\; e_0\; (\cons\; e_1\; e_2) \reduces f\; e_1\; (\foldr\; f\; e_0\; e_2)}{f \val & e_0 \val & \cons\; e_1\; e_2 \val}
    % \\\\
    % % \infer{\ttt{scanr f z $e$} \reduces \ttt{cons e$'$ (f x
    \\\\
    \labinfer[Fst-1]{\fst\; e \reduces \fst\; e'}{e \reduces e'}
    ~~~
    \labinfer[Snd-1]{\snd\; e \reduces \snd\; e'}{e \reduces e'}
    \\\\
    \labinfer[Fst-Pair]{\fst\; (\pair\; e_1\; e_2) \reduces e_1}{\pair\; e_1\; e_2 \val}
    ~~~
    \labinfer[Snd-Pair]{\snd\; (\pair\; e_1\; e_2) \reduces e_2}{\pair\; e_1\; e_2 \val}
    \\\\
    \labinfer[IfThenElse-1]{\ite\; b\; e_1\; e_2 \reduces \ite\; b'\; e_1\; e_2}{b \reduces b'}
    \\\\
    \labinfer[IfThenElse-True]{\ite\; \True\; e_1\; e_2 \reduces e_1}{}
    ~~~
    \labinfer[IfThenElse-False]{\ite\; \False\; e_1\; e_2 \reduces e_2}{}
    \\\\
    \labinfer[Le-1]{\lesseq\; e_1\; e_2 \reduces \lesseq\; e_1'\; e_2}{e_1 \reduces e_1'}
    ~~~
    \labinfer[Le-2]{\lesseq\; e_1\; e_2 \reduces \lesseq\; e_1\; e_2'}{e_1 \val & e_2 \reduces e_2'}
    \\\\
    \labinfer[Le-<]{\lesseq\; e_1\; e_2 \reduces \True}{e_1 \val & e_2 \val & e_1 < e_2}
    ~~~
    \labinfer[Le-=]{\lesseq\; e\; e \reduces \True}{e \val}
    \\\\
    \labinfer[Le-False]{\lesseq\; e_1\; e_2 \reduces \False}{e_1 \val & e_2 \val & e_1 > e_2}
    \\\\
    \labinfer[Eq-1]{\eq\; e_1\; e_2 \reduces \eq\; e_1'\; e_2}{e_1 \reduces e_1'}
    ~~~
    \labinfer[Eq-1]{\eq\; e_1\; e_2 \reduces \eq\; e_1\; e_2'}{e_1 \val & e_2 \reduces e_2'}
    \\\\
    \labinfer[Eq-True]{\eq\; e\; e \reduces \True}{e \val}
    ~~~
    \labinfer[Eq-False]{\eq\; e_1\; e_2 \reduces \False}{e_1 \val & e_2 \val & e_1 \neq e_2}
    
  \end{array}
\]

\noindent
Let $\reducestr$ be the transitive, reflexive closure of $\reduces$.

\begin{theorem}[Progress]
  $\forall e.\; e \val \lor (\exists e'.\; e \reduces e')$
\end{theorem}

\begin{theorem}[Preservation]
  \text{If} $e : T$ \text{and} $e \reduces e'$ \text{then} $e' : T$
\end{theorem}

\begin{theorem}[Uniqueness of Normal Forms]
  \text{If} $e : T$, $v \val$, $v' \val$, $e \reducestr v$ \text{and} $e \reducestr v'$ \text{then} $v = v'$
\end{theorem}

\section{Ghost Approximation}

Each subexpression will be assigned a SuSLik ghost variable. This is to specify
that results are passed from one heaplet to another. This cannot be done directly
through reusing memory locations across heaplets, since this is not allowed by
separating conjunction.

% The function $G : (\text{Ctx} \times \text{Expr}) \ra \text{Name}$ maps subexpressions into their corresponding ghost variable.

There are three kinds of ghost variables: \verb|bool|, \verb|int| and \verb|set|. The latter
represents sets of \verb|int|s. A lambda at the top-level of a program cannot be translated into
SuSLik. However, lambdas are allowed at subexpressions as long as there are no redexes. Redexes will
be $\beta$-reduced before applying the following translation.
\\

\noindent
\textit{Preconditions for an expression to be translated into SuSLik ghost variables}:
\begin{itemize}
  \item No $\beta$-redexes
  \item No nested structures, since we only have \verb|intset| ghost variables,
    and no ghost variables which can reflect these more complicated structures. This requirement might be either lifted or relaxed later, depending on
    if we can find a way to extend SuSLik's capabilities or a way to mitigate this limitation.\\
    One way could be to provide SuSLik with a program
    sketch which directly implements the passing of results from one procedure to another. In order for this to work, a SuSLik bug that limits
    its symbolic execution capabilities must be fixed.
\end{itemize}

\noindent
This translation is necessary, as SuSLik uses these ghost variables to specify particular computations. Note that when we translate to
\verb|intset|s, we forget certain things about the original list (in particular, the ordering of the elements and whether there are "extra"
elements). We will now describe this translation, and these limitations, in more detail.

In effect, this restriction to \verb|intset|s \textit{requires} that we perform a kind of abstract interpretation of fun-SuSLik into the
abstract domain of SuSLik ghost values in order to arrive at an appropriate notion of preservation of semantics when we
translate from fun-SuSLik into SuSLik.


\noindent
The general pipeline of the semantics translation looks like this:

\[
  {\scriptstyle \text{Operational Semantics of fun-SuSLik} \ra \text{Approximation by SuSLik ghost values} \ra \text{Semantics of SuSLik}}
\]

\noindent
The semantic function which translate fun-SuSLik values is given by
\[
  \Gsem{\cdot} : Expr \ra \mathcal{P}(\mathcal{P}(\mathbb{Z}))
\]

\noindent
Note that $\mathcal{P}(\mathbb{Z})$ is the set of all possible values of type \verb|intset|.\\

The image of a fun-SuSLik expression in $\Gsem{\cdot}$ is the
set of all possible ghost values that can represent it. For example, for a fun-SuSLik list \verb|cons 1 (cons 2 (cons 3 nil))|, the possible
ghost values would be all \verb|intset|s that contain \ttt{1}, \ttt{2} and \ttt{3}. Compare this with the fun-SuSLik expression
\verb|head e|. After translating this to ghost values, all we know is that the result will be some value in the
list \verb|e|. By translating into sets, we've forgotten exactly which one it will be.

We are particularly interested in \textit{minimal (non-empty) elements} in the image of
$\Gsem{\cdot}$. Again, consider the case of $\Gsem{\cons\; 1\; (\cons\; 2\; (\cons\; 3\; \nil))}$.
This will translate to the set of all supersets of $\{1,2,3\}$. However, there we notice that one
element of this set is most "important": the set $\{1,2,3\}$ itself. This set corresponds
\textit{exactly} to the elements of the original list, without containing any
"extra" elements.

Also notice that, if you consider the $\subseteq$ partial order,
this set is the \textit{minimal} set in $\Gsem{\cons\; 1\; (\cons\; 2\; (\cons\; 3\; \nil))}$. To say this another way:
the greatest lower bound of $\Gsem{\cons\; 1\; (\cons\; 2\; (\cons\; 3\; \nil))}$ is $\{1,2,3\}$. In mathematical notation,
we can write:

\[
  \bigcap\Gsem{\cons\; 1\; (\cons\; 2\; (\cons\; 3\; \nil))} = \{1, 2, 3\}
\]

Further, note that there are cases where the greatest lower bound is just $\emptyset$. This is the case for \verb|head e|, as mentioned
above. To see this, observe that $\{\{1\},\{2\},\{3\}\} \subseteq \Gsem{\head\; (\cons\; 1\; (\cons\; 2\; (\cons\; 3\; \nil)))}$. Therefore,
we see that $\bigcap{\Gsem{\head\; (\cons\; 1\; (\cons\; 2\; (\cons\; 3\; \nil)))}} = \emptyset$.

Thus, we are more interested in the \textit{atoms} in the image of $\Gsem{\cdot}$. An atom is any minimal element that is
strictly greater than the least element (the least element is $\emptyset$ in our case). Continuing our example, the atoms of $\Gsem{\head\; (\cons\; 1\; (\cons\; 2\; (\cons\; 3\; \nil)))}$ are $\{1\}$, $\{2\}$ and $\{3\}$. Furthermore, the unique atom of $\Gsem{\cons\; 1\; (\cons\; 2\; (\cons\; 3\; \nil))}$ is $\{1,2,3\}$.

We can see that we do not just want to look at the minimal elements, we want to look at the \textit{atoms}. For this, we use the
following notation: Let $\Atoms X$ be the set of all atoms in $X$.

\noindent
The general list of rules for $\Gsem{\cdot}$ are given here:

\[
  \begin{array}{cc}
    \Gsem{\nil} = \emptyset
    ~~~~~
    \Atoms\Gsem{\cons\; e_1\; e_2} = \{ \Atoms\Gsem{e_1} \cup a\; |\; a \in \Atoms\Gsem{e_2} \}
    % \Atoms\Gsem{\cons\; e_1\; e_2} = \{ \Atoms\Gsem{e_1} \} \cup \Atoms\Gsem{e_2}
  \end{array}
\]


\section{Translation Into SuSLik}


\noindent
The translation into SuSLik will be given by the semantic function $\Ssem{\cdot}$

\noindent
\textbf{TODO:} Rewrite this to use the ghost variable approximation

\[
  \begin{array}{cc}
    \Ssem{\letbnd\; x\; \ttt{:=}\; e\; \inexpr\; e_2} = x \mapsto v * \Ssem{e_2}(v) * \Ssem{e}(v)~~~\text{where $v \notin FV(\Ssem{e}) \cup FV(\Ssem{e_2})$}
    \\
    \Ssem{\lambda\; x\; \ra\; e} = \text{pred}(x) \Ra \Ssem{e}
    % \\
    % \sem{\cons\; e_1\; e_2} = \text{cons}(v
  \end{array}
\]


\end{document}

