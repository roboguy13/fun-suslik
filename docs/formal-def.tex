\documentclass[10pt]{article}
\usepackage{amsmath, listings, amsthm, amssymb, proof, syntax}
\usepackage[T1]{fontenc}
\usepackage{scrlayer-scrpage}

\newtheorem{theorem}{Theorem}

\renewcommand{\syntleft}{}
\renewcommand{\syntright}{}

\newcommand{\infers}{\ensuremath{\Rightarrow}}
\newcommand{\checks}{\ensuremath{\Leftarrow}}

\newcommand{\ttt}[1]{\texttt{#1}}
\newcommand{\ra}{\ensuremath{\rightarrow}}

\newcommand{\reduces}{\ensuremath{\longmapsto}}
\newcommand{\reducestr}{\ensuremath{\longmapsto^{*}}}

\newcommand{\val}{\textnormal{ val}}

\newcommand{\True}{\ttt{True}}
\newcommand{\False}{\ttt{False}}
\newcommand{\head}{\ttt{head}}
\newcommand{\tail}{\ttt{tail}}
\newcommand{\cons}{\ttt{cons}}
\newcommand{\nil}{\ttt{nil}}
\newcommand{\unit}{\ttt{unit}}
\newcommand{\foldr}{\ttt{foldr}}
% \newcommand{\scanr}{\ttt{scanr}}
\newcommand{\pair}{\ttt{pair}}
\newcommand{\fst}{\ttt{fst}}
\newcommand{\snd}{\ttt{snd}}
\newcommand{\ite}{\ttt{if}}

\newcommand{\Int}{\ttt{Int}}
\newcommand{\Bool}{\ttt{Bool}}
\newcommand{\tyUnit}{\ttt{Unit}}
\newcommand{\tyPair}{\ttt{Pair}}
\newcommand{\List}{\ttt{List}}
\newcommand{\letbnd}{\ttt{let}}
\newcommand{\inexpr}{\ttt{in}}
\newcommand{\defeq}{\ttt{:=}}

\newcommand{\lesseq}{\ttt{le}}
\newcommand{\eq}{\ttt{eq}}

\newcommand{\labinfer} [3] [] {\infer[{\small\textsc{#1}}]{#2}{#3}}

\begin{document}

\section{Syntax}

\begin{grammar}
  <I> ::= ... | -1 | 0 | 1 | ...

  <B> ::= \ttt{True} | \ttt{False}

  <D> ::= \ttt{x :} <T>; x <P> \ttt{:=} <e>;

  <P> ::= $\varepsilon$ | x <P>

  <e> ::= <e>$_0$ | <e> <e>$_0$

  <e$_0$> ::= <I> | <B> | \ttt{unit} | <L> | <C> | \letbnd\; x \ttt{:=} <e> \inexpr\; <e> | ( <e> )

  <L> ::= $\lambda x \ra$ <e>

  <C> ::= \head\; | \tail\; | \cons\; | \nil\; | \foldr\; | \pair\; | \fst\; | \snd\; | \ite\; | \lesseq\; | \eq

  <T> ::= \ttt{Int} | \ttt{Bool} | \ttt{Unit} | <T> $\ra$ <T> | \ttt{List} <T> | \ttt{Pair} <T> <T> | ( <T> )

  <$\Gamma$> ::= $\cdot$ | x : <T>, $\Gamma$
\end{grammar}

\section{Typing Judgments}

\[
  \begin{array}{cc}
    \infer{\Gamma \vdash x : T}{(x : T) \in \Gamma}
    ~~~
    \infer{\vdash i : \ttt{Int}}{i \in \mathbb{Z}}
    \\\\
    \infer{\vdash \ttt{unit} : \ttt{Unit}}{}
    ~~~
    \infer{\vdash \ttt{True} : \ttt{Bool}}{}
    ~~~
    \infer{\vdash \ttt{False} : \ttt{Bool}}{}
    \\\\
    \infer{\Gamma \vdash t_0\; t_1 : T'}{\Gamma \vdash t_0 : T \ra T' & \Gamma \vdash t_1 : T}
    \\\\
    \infer{\Gamma \vdash \lambda x \ra t : T \ra T'}{x : T, \Gamma \vdash t : T'}
    \\\\
    \infer{\Gamma \vdash \letbnd\; x\; \ttt{:=}\; e\; \inexpr\; e' : T'}{\Gamma \vdash e : T & x : T, \Gamma \vdash e' : T'}
    \\\\
    \infer{\vdash \ttt{nil} : \List\; T}{}
    ~~~
    \infer{\vdash \ttt{cons} : T \ra \List\; T \ra \List\; T}{}
    \\\\
    \infer{\vdash \ttt{head} : \List\; T \ra T}{}
    ~~~
    \infer{\vdash \ttt{tail} : \List\; T \ra \List\; T}{}
    \\\\
    \infer{\vdash \ttt{foldr} : (T \ra T' \ra T') \ra T' \ra \List\; T \ra T'}{}
    \\\\
    \infer{\vdash \ttt{pair} : T \ra T' \ra \tyPair\; T\; T'}{}
    ~~~
    \infer{\vdash \ttt{fst} : \tyPair\; T\; T' \ra T}{}
    ~~~
    \infer{\vdash \ttt{snd} : \tyPair\; T\; T' \ra T'}{}
    \\\\
    \infer{\vdash \ttt{ifThenElse} : \Bool \ra T \ra T \ra T}{}
    \\\\
    \infer{\vdash \ttt{le} : \Int \ra \Int \ra \Bool}{}
    ~~~
    \infer{\vdash \ttt{eq} : \Int \ra \Int \ra \Bool}{}
  \end{array}
\]

\section{Small-Step Operational Semantics}

First, the ``value'' judgment val (as in Harper's Practical Foundations for Programming Languages, Sec. 19.2):

\[
  \begin{array}{cc}
    \infer{i \val}{i \in \mathbb{Z}}
    ~~~
    \infer{\unit \val}{}
    ~~~
    \infer{\True \val}{}
    ~~~
    \infer{\False \val}{}
    ~~~
    \infer{\nil \val}{}
    \\\\
    \infer{\cons\; e_1\; e_2 \val}{e_1 \val & e_2 \val}
    ~~~
    \infer{\pair\; e_1\; e_2 \val}{e_1 \val & e_2 \val}
    ~~~
    \infer{\lambda x \ra e \val}{}
  \end{array}
\]

\noindent
Now the small-step reduction relation $\reduces$


\[
  \begin{array}{cc}
    \labinfer[App-1]{e_1\; e_2 \reduces e_1\; e_2'}{e_2 \reduces e_2'}
    ~~~
    \labinfer[App-2]{e_1\; e_2 \reduces e_1'\; e_2}{e_1 \reduces e_1' & e_2 \val}
    ~~~
    \labinfer[App-$\lambda$]{(\lambda x \ra e)\; e_2 \reduces e[x\mapsto e_2]}{e_2 \val}
    \\\\
    \labinfer[Let-Bnd]{\letbnd\; x\; \ttt{:=}\; e_1\; \inexpr\; e_2 \reduces \letbnd\; x\; \ttt{:=}\; e_1'\; \inexpr\; e_2}
       {e_1 \reduces e_1'}
    \\\\
    \labinfer[Let-Subst]{\letbnd\; x\; \ttt{:=}\; e_1\; \inexpr\; e_2 \reduces e_2[x\mapsto e_1]}{e_1 \val}
    \\\\
    \labinfer[Cons-1]{\cons\; e_1\; e_2 \reduces \cons\; e_1'\; e_2}{e_1 \reduces e_2}
    ~~~
    \labinfer[Cons-2]{\cons\; e_1\; e_2 \reduces \cons\; e_1\; e_2'}{e_1 \val & e_2 \reduces e_2'}
    \\\\
    \labinfer[Head-1]{\head\; e \reduces \head\; e'}{e \reduces e'}
    ~~~
    \labinfer[Tail-1]{\tail\; e \reduces \tail\; e'}{e \reduces e'}
    \\\\
    \labinfer[Head-Cons]{\head\; (\cons\; e_1\; e_2) \reduces e_1}{\cons\; e_1\; e_2 \val}
    ~~~
    \labinfer[Tail-Cons]{\tail\; (\cons\; e_1\; e_2) \reduces e_2}{\cons\; e_1\; e_2 \val}
    \\\\
    \labinfer[Pair-1]{\pair\; e_1\; e_2 \reduces \pair\; e_1'\; e_2}{e_1 \reduces e_1}
    ~~~~
    \labinfer[Pair-2]{\pair\; e_1\; e_2 \reduces \pair\; e_1\; e_2'}{e_1 \val & e_2 \reduces e_2'}
    \\\\
    \labinfer[Foldr-1]{\foldr\; f\; z\; e \reduces \foldr\; f'\; z\; e}{f \reduces f'}
    ~~~
    \labinfer[Foldr-2]{\foldr\; f\; z\; e \reduces \foldr\; f\; z'\; e}{f \val & z \reduces z'}
    \\\\
    \labinfer[Foldr-3]{\foldr\; f\; z\; e \reduces \foldr\; f\; z\; e'}{f \val & z \val & e \reduces e'}
    \\\\
    \labinfer[Foldr-Cons]{\foldr\; f\; z\; (\cons\; x\; xs) \reduces f\; x\; (\foldr\; f\; z\; xs)}{f \val & z \val & \cons\; x\; xs \val}
    % \\\\
    % % \infer{\ttt{scanr f z $e$} \reduces \ttt{cons e$'$ (f x
    \\\\
    \labinfer[Fst-1]{\fst\; e \reduces \fst\; e'}{e \reduces e'}
    ~~~
    \labinfer[Snd-1]{\snd\; e \reduces \snd\; e'}{e \reduces e'}
    \\\\
    \labinfer[Fst-Pair]{\fst\; (\pair\; e_1\; e_2) \reduces e_1}{\pair\; e_1\; e_2 \val}
    ~~~
    \labinfer[Snd-Pair]{\snd\; (\pair\; e_1\; e_2) \reduces e_2}{\pair\; e_1\; e_2 \val}
    \\\\
    \labinfer[IfThenElse-1]{\ite\; b\; e_1\; e_2 \reduces \ite\; b'\; e_1\; e_2}{b \reduces b'}
    \\\\
    \labinfer[IfThenElse-True]{\ite\; \True\; e_1\; e_2 \reduces e_1}{}
    ~~~
    \labinfer[IfThenElse-False]{\ite\; \False\; e_1\; e_2 \reduces e_2}{}
    \\\\
    \labinfer[Le-1]{\lesseq\; e_1\; e_2 \reduces \lesseq\; e_1'\; e_2}{e_1 \reduces e_1'}
    ~~~
    \labinfer[Le-2]{\lesseq\; e_1\; e_2 \reduces \lesseq\; e_1\; e_2'}{e_1 \val & e_2 \reduces e_2'}
    \\\\
    \labinfer[Le-<]{\lesseq\; e_1\; e_2 \reduces \True}{e_1 \val & e_2 \val & e_1 < e_2}
    ~~~
    \labinfer[Le-=]{\lesseq\; e\; e \reduces \True}{e \val}
    \\\\
    \labinfer[Le-False]{\lesseq\; e_1\; e_2 \reduces \False}{e_1 \val & e_2 \val & e_1 > e_2}
    \\\\
    \labinfer[Eq-1]{\eq\; e_1\; e_2 \reduces \eq\; e_1'\; e_2}{e_1 \reduces e_1'}
    ~~~
    \labinfer[Eq-1]{\eq\; e_1\; e_2 \reduces \eq\; e_1\; e_2'}{e_1 \val & e_2 \reduces e_2'}
    \\\\
    \labinfer[Eq-True]{\eq\; e\; e \reduces \True}{e \val}
    ~~~
    \labinfer[Eq-False]{\eq\; e_1\; e_2 \reduces \False}{e_1 \val & e_2 \val & e_1 \neq e_2}
    
  \end{array}
\]

\noindent
Let $\reducestr$ be the transitive, reflexive closure of $\reduces$.

\begin{theorem}[Progress]
  $\forall e.\; e \val \lor (\exists e'.\; e \reduces e')$
\end{theorem}

\begin{theorem}[Preservation]
  \text{If} $e : T$ \text{and} $e \reduces e'$ \text{then} $e' : T$
\end{theorem}

\begin{theorem}[Uniqueness of Normal Forms]
  \text{If} $e : T$, $v \val$, $v' \val$, $e \reducestr v$ \text{and} $e \reducestr v'$ \text{then} $v = v'$
\end{theorem}



\end{document}

