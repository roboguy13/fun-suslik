\documentclass[10pt]{article}
\usepackage{amsmath, listings, amsthm, amssymb, latexsym, proof, syntax, stmaryrd, tikz-cd}
\usepackage[T1]{fontenc}
\usepackage{scrlayer-scrpage}

\newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition}

% \renewcommand{\syntleft}{}
% \renewcommand{\syntright}{}

\newcommand{\infers}{\ensuremath{\Rightarrow}}
\newcommand{\checks}{\ensuremath{\Leftarrow}}

\newcommand{\ttt}[1]{\texttt{#1}}
\newcommand{\ra}{\ensuremath{\rightarrow}}
\newcommand{\Ra}{\ensuremath{\Rightarrow}}

\newcommand{\reduces}{\ensuremath{\longmapsto}}
\newcommand{\reducestr}{\ensuremath{\longmapsto^{*}}}

\newcommand{\BigStep}{\ensuremath{\Downarrow}}

\newcommand{\val}{\textnormal{ val}}

\newcommand{\True}{\ttt{True}}
\newcommand{\False}{\ttt{False}}
\newcommand{\head}{\ttt{head}}
\newcommand{\tail}{\ttt{tail}}
\newcommand{\cons}{\ttt{cons}}
\newcommand{\nil}{\ttt{nil}}
\newcommand{\unit}{\ttt{unit}}
\newcommand{\foldr}{\ttt{foldr}}
% \newcommand{\scanr}{\ttt{scanr}}
\newcommand{\pair}{\ttt{pair}}
\newcommand{\fst}{\ttt{fst}}
\newcommand{\snd}{\ttt{snd}}
\newcommand{\ite}{\ttt{if}}

\newcommand{\Int}{\ttt{Int}}
\newcommand{\Bool}{\ttt{Bool}}
\newcommand{\tyUnit}{\ttt{Unit}}
\newcommand{\tyPair}{\ttt{Pair}}
\newcommand{\List}{\ttt{List}}
\newcommand{\letbnd}{\ttt{let}}
\newcommand{\inexpr}{\ttt{in}}
\newcommand{\defeq}{\ttt{:=}}

\newcommand{\intS}{\ttt{int}}
\newcommand{\intset}{\ttt{intset}}
\newcommand{\bool}{\ttt{bool}}
\newcommand{\pred}{\ttt{pred}}

\newcommand{\true}{\ttt{true}}
\newcommand{\false}{\ttt{false}}

\newcommand{\upperS}{\ttt{upper}}
\newcommand{\lowerS}{\ttt{lower}}

\newcommand{\lesseq}{\ttt{le}}
\newcommand{\eq}{\ttt{eq}}

\newcommand{\labinfer} [3] [] {\infer[{\small\textsc{#1}}]{#2}{#3}}

\newcommand{\sem} [1] {\llbracket#1\rrbracket}
\newcommand{\Gsem} [1] {\mathcal{G}\sem{#1}}
\newcommand{\Ssem} [1] {\mathcal{S}\sem{#1}}
\newcommand{\Gapprox} {\approx}
\newcommand{\Atoms} {\mathcal{A}}

\newcommand{\partialfn} {\rightharpoonup}
\newcommand{\PZ} {\mathcal{P}(\mathbb{Z})}
\newcommand{\PPZ} {\mathcal{P}(\PZ)}

\newcommand{\sqle} [1] {\sqsubseteq_{#1}}
\newcommand{\boolLE} {\sqle{\bool}}
\newcommand{\intLE} {\sqle{\intS}}
\newcommand{\intsetLE} {\sqle{\intset}}

\newcommand\scalemath[2]{\scalebox{#1}{\mbox{\ensuremath{\displaystyle #2}}}}
\renewcommand{\arraystretch}{0.5}

\begin{document}

\section{Introduction}

In this document, we give a translation from fun-SuSLik to SuSLik. First, we define the syntax and
operational semantics of the two languages. Then, we give definitions of equivalence in terms of these
operational semantics. The translation from fun-SuSLik is represented as a denotational semantics
that denotes a fun-SuSLik expression as a SuSLik specification. Finally, we prove that this denotational
semantics preserves equivalence by proving adequacy and full abstraction.


% In this document, we describe the semantics of fun-SuSLik and translate them
% into SuSLik's semantics. Then, we translate both fun-SuSLik and SuSLik into a
% category of abstract stores and mappings between of abstract stores. An abstract store is a
% mapping from locations to values of a base type or a tuple of base types (here, the base types are \verb|int| and \verb|bool|).
% By ``location,'' we mean an abstract location: it is not represented as a number and therefore
% you cannot perform pointer arithmetic on it. We do this to avoid these extra details, which
% are not relevant to proving semantics preservation.
%
% An overview of this is given in the diagram below.
% \\
%
% \begin{tikzcd}
%   \text{fun-SuSLik} \arrow[d, "\Gsem{\cdot}"] \arrow[r, swap, "\sigma_{\mathcal{FS}}"]
%   &
%   \text{Abstract stores} \arrow[dddl, "id"]
%   \\
%   \text{Ghost approximation} \arrow[d, "\Ssem{\cdot}"]
%   \\
%   \text{SuSLik} \arrow[d, "\sigma_{\mathcal{S}}"]
%   \\
%   \text{Abstract stores}
%   % \\
%   % \text{Abstract stores}
% \end{tikzcd}
%
% ~\\
% \noindent
% We show that the translation of fun-SuSLik into SuSLik is semantics preserving by proving that this diagram commutes.
% \\
%
% \noindent
% The four categories involved are:
%
% \begin{itemize}
%   \item The fun-SuSLik category of fun-SuSLik values and fun-SuSLik functions
%   \item The ghost approximation category of SuSLik ghost values and functions between them. These ghost values are the values which are manipulated in the pure part of a SuSLik assertion
%   \item The SuSLik category of heaps and SuSLik functions
%   \item The abstract stores category of abstract stores and mappings between abstract stores
% \end{itemize}
%
%

\section{fun-SuSLik Language Definition}
\subsection{Syntax}

\begin{grammar}
  <I> ::= ... | -1 | 0 | 1 | ...

  <B> ::= \ttt{True} | \ttt{False}

  <D> ::= \ttt{x :} <T>; x <P> \ttt{:=} <e>;

  <P> ::= $\varepsilon$ | x <P>

  <e> ::= <e>$_0$ | <e> <e>$_0$

  <e$_0$> ::= <I> | <B> | \ttt{unit} | <L> | <C> | \letbnd\; x \ttt{:=} <e> \inexpr\; <e> | ( <e> )

  <L> ::= $\lambda x \ra$ <e>

  <C> ::= \head\; | \tail\; | \cons\; | \nil\; | \foldr\; | \pair\; | \fst\; | \snd\; | \ite\; | \lesseq\; | \eq

  <T> ::= \ttt{Int} | \ttt{Bool} | \ttt{Unit} | <T> $\ra$ <T> | \ttt{List} <T> | \ttt{Pair} <T> <T> | ( <T> )

  <$\Gamma$> ::= $\cdot$ | x : <T>, $\Gamma$
\end{grammar}

\subsection{Typing Judgment}

\[
  \begin{array}{c}[t]
    \infer{\Gamma \vdash x : T}{(x : T) \in \Gamma}
    ~~~
    \infer{\vdash i : \ttt{Int}}{i \in \mathbb{Z}}
    \\\\
    \infer{\vdash \ttt{unit} : \ttt{Unit}}{}
    ~~~
    \infer{\vdash \ttt{True} : \ttt{Bool}}{}
    ~~~
    \infer{\vdash \ttt{False} : \ttt{Bool}}{}
    \\\\
    \infer{\Gamma \vdash t_0\; t_1 : T'}{\Gamma \vdash t_0 : T \ra T' & \Gamma \vdash t_1 : T}
    \\\\
    \infer{\Gamma \vdash \lambda x \ra t : T \ra T'}{x : T, \Gamma \vdash t : T'}
    \\\\
    \infer{\Gamma \vdash \letbnd\; x\; \ttt{:=}\; e\; \inexpr\; e' : T'}{\Gamma \vdash e : T & x : T, \Gamma \vdash e' : T'}
    \\\\
    \infer{\vdash \ttt{nil} : \List\; T}{}
    ~~~
    \infer{\vdash \ttt{cons} : T \ra \List\; T \ra \List\; T}{}
    \\\\
    \infer{\vdash \ttt{head} : \List\; T \ra T}{}
    ~~~
    \infer{\vdash \ttt{tail} : \List\; T \ra \List\; T}{}
    \\\\
    \infer{\vdash \ttt{foldr} : (T \ra T' \ra T') \ra T' \ra \List\; T \ra T'}{}
    \\\\
    \infer{\vdash \ttt{pair} : T \ra T' \ra \tyPair\; T\; T'}{}
    ~~~
    \infer{\vdash \ttt{fst} : \tyPair\; T\; T' \ra T}{}
    ~~~
    \infer{\vdash \ttt{snd} : \tyPair\; T\; T' \ra T'}{}
    \\\\
    \infer{\vdash \ttt{ifThenElse} : \Bool \ra T \ra T \ra T}{}
    \\\\
    \infer{\vdash \ttt{le} : \Int \ra \Int \ra \Bool}{}
    ~~~
    \infer{\vdash \ttt{eq} : \Int \ra \Int \ra \Bool}{}
  \end{array}
\]

\subsection{Small-Step Operational Semantics}

First, the ``value'' judgment val (as in Harper's Practical Foundations for Programming Languages, Sec. 19.2):

\[
  \begin{array}{cc}
    \infer{i \val}{i \in \mathbb{Z}}
    ~~~
    \infer{\unit \val}{}
    ~~~
    \infer{\True \val}{}
    ~~~
    \infer{\False \val}{}
    ~~~
    \infer{\nil \val}{}
    \\\\
    \infer{\cons\; e_1\; e_2 \val}{e_1 \val & e_2 \val}
    ~~~
    \infer{\pair\; e_1\; e_2 \val}{e_1 \val & e_2 \val}
    ~~~
    \infer{\lambda x \ra e \val}{}
  \end{array}
\]

\noindent
Now the small-step reduction relation $\reduces$


\[
  \begin{array}{cc}
    \labinfer[App-1]{e_1\; e_2 \reduces e_1\; e_2'}{e_2 \reduces e_2'}
    ~~~
    \labinfer[App-2]{e_1\; e_2 \reduces e_1'\; e_2}{e_1 \reduces e_1' & e_2 \val}
    ~~~
    \labinfer[App-$\lambda$]{(\lambda x \ra e)\; e_2 \reduces e[x\mapsto e_2]}{e_2 \val}
    \\\\
    \labinfer[Let-Bnd]{\letbnd\; x\; \ttt{:=}\; e_1\; \inexpr\; e_2 \reduces \letbnd\; x\; \ttt{:=}\; e_1'\; \inexpr\; e_2}
       {e_1 \reduces e_1'}
    \\\\
    \labinfer[Let-Subst]{\letbnd\; x\; \ttt{:=}\; e_1\; \inexpr\; e_2 \reduces e_2[x\mapsto e_1]}{e_1 \val}
    \\\\
    \labinfer[Cons-1]{\cons\; e_1\; e_2 \reduces \cons\; e_1'\; e_2}{e_1 \reduces e_2}
    ~~~
    \labinfer[Cons-2]{\cons\; e_1\; e_2 \reduces \cons\; e_1\; e_2'}{e_1 \val & e_2 \reduces e_2'}
    \\\\
    \labinfer[Head-1]{\head\; e \reduces \head\; e'}{e \reduces e'}
    ~~~
    \labinfer[Tail-1]{\tail\; e \reduces \tail\; e'}{e \reduces e'}
    \\\\
    \labinfer[Head-Cons]{\head\; (\cons\; e_1\; e_2) \reduces e_1}{\cons\; e_1\; e_2 \val}
    ~~~
    \labinfer[Tail-Cons]{\tail\; (\cons\; e_1\; e_2) \reduces e_2}{\cons\; e_1\; e_2 \val}
    \\\\
    \labinfer[Pair-1]{\pair\; e_1\; e_2 \reduces \pair\; e_1'\; e_2}{e_1 \reduces e_1}
    ~~~~
    \labinfer[Pair-2]{\pair\; e_1\; e_2 \reduces \pair\; e_1\; e_2'}{e_1 \val & e_2 \reduces e_2'}
    \\\\
    \labinfer[Foldr-1]{\foldr\; f\; e_0\; e \reduces \foldr\; f'\; e_0\; e}{f \reduces f'}
    ~~~
    \labinfer[Foldr-2]{\foldr\; f\; e_0\; e \reduces \foldr\; f\; e_0'\; e}{f \val & e_0 \reduces e_0'}
    \\\\
    \labinfer[Foldr-3]{\foldr\; f\; e_0\; e \reduces \foldr\; f\; e_0\; e'}{f \val & e_0 \val & e \reduces e'}
    \\\\
    \labinfer[Foldr-Cons]{\foldr\; f\; e_0\; (\cons\; e_1\; e_2) \reduces f\; e_1\; (\foldr\; f\; e_0\; e_2)}{f \val & e_0 \val & \cons\; e_1\; e_2 \val}
    % \\\\
    % % \infer{\ttt{scanr f z $e$} \reduces \ttt{cons e$'$ (f x
    \\\\
    \labinfer[Fst-1]{\fst\; e \reduces \fst\; e'}{e \reduces e'}
    ~~~
    \labinfer[Snd-1]{\snd\; e \reduces \snd\; e'}{e \reduces e'}
    \\\\
    \labinfer[Fst-Pair]{\fst\; (\pair\; e_1\; e_2) \reduces e_1}{\pair\; e_1\; e_2 \val}
    ~~~
    \labinfer[Snd-Pair]{\snd\; (\pair\; e_1\; e_2) \reduces e_2}{\pair\; e_1\; e_2 \val}
    \\\\
    \labinfer[IfThenElse-1]{\ite\; b\; e_1\; e_2 \reduces \ite\; b'\; e_1\; e_2}{b \reduces b'}
    \\\\
    \labinfer[IfThenElse-True]{\ite\; \True\; e_1\; e_2 \reduces e_1}{}
    ~~~
    \labinfer[IfThenElse-False]{\ite\; \False\; e_1\; e_2 \reduces e_2}{}
    \\\\
    \labinfer[Le-1]{\lesseq\; e_1\; e_2 \reduces \lesseq\; e_1'\; e_2}{e_1 \reduces e_1'}
    ~~~
    \labinfer[Le-2]{\lesseq\; e_1\; e_2 \reduces \lesseq\; e_1\; e_2'}{e_1 \val & e_2 \reduces e_2'}
    \\\\
    \labinfer[Le-<]{\lesseq\; e_1\; e_2 \reduces \True}{e_1 \val & e_2 \val & e_1 < e_2}
    ~~~
    \labinfer[Le-=]{\lesseq\; e\; e \reduces \True}{e \val}
    \\\\
    \labinfer[Le-False]{\lesseq\; e_1\; e_2 \reduces \False}{e_1 \val & e_2 \val & e_1 > e_2}
    \\\\
    \labinfer[Eq-1]{\eq\; e_1\; e_2 \reduces \eq\; e_1'\; e_2}{e_1 \reduces e_1'}
    ~~~
    \labinfer[Eq-1]{\eq\; e_1\; e_2 \reduces \eq\; e_1\; e_2'}{e_1 \val & e_2 \reduces e_2'}
    \\\\
    \labinfer[Eq-True]{\eq\; e\; e \reduces \True}{e \val}
    ~~~
    \labinfer[Eq-False]{\eq\; e_1\; e_2 \reduces \False}{e_1 \val & e_2 \val & e_1 \neq e_2}

  \end{array}
\]

\noindent
Let $\reducestr$ be the transitive, reflexive closure of $\reduces$.

\begin{theorem}[Progress]
  $\forall e.\; e \val \lor (\exists e'.\; e \reduces e')$
\end{theorem}

\begin{theorem}[Preservation]
  \text{If} $e : T$ \text{and} $e \reduces e'$ \text{then} $e' : T$
\end{theorem}

\begin{theorem}[Uniqueness of Normal Forms]
  \text{If} $e : T$, $v \val$, $v' \val$, $e \reducestr v$ \text{and} $e \reducestr v'$ \text{then} $v = v'$
\end{theorem}

\noindent
We now define equivalence of fun-SuSLik programs.

\begin{definition}[Termination]
  $e$ \text{is \textnormal{terminating} iff} $\exists v.\; v \val \land e \reducestr v$.\\
  $e$ \text{is \textnormal{nonterminating} iff it is not terminating}
\end{definition}

\begin{definition}[fun-SuSLik Equivalence]
  If $e$ and $e'$ are both nonterminating, then $e \approx_F e'$.\\
  If $e$ and $e'$ are both terminating, then $e \approx_F e'$ iff $\exists v. e \reducestr v \land e' \reducestr v$\\
  Otherwise, $e$ and $e'$ are not equivalent and we write $e \not\approx_F e'$
\end{definition}

\section{SuSLik Assertion Language}

We define the syntax of the SuSLik assertion language and then an equivalence of assertions.

\begin{grammar}
  <n> ::= 0 | 1 | ...

  <i> ::= ... | -1 | 0 | 1 | ...

  <B> ::= \true | \false

  <IS> ::= \{\} | \{ <IL> \} | <IS> -{}- <IS> | <IS> ++ <IS>

  <IL> ::= <i> | <i> , <IL>

  <H> ::= emp | x :-> <t> | [x, <n>]

  <t> ::= x | <i> | <IS> | ( <t> ) | <P> | <t> + <t> | <t> - <t> | <t> * <t>

  <P> ::= <B> | <t> == <t> | <t> $\le$ <t> | not <P> | <P> \&\& <P> | <P> $||$ <P> | <P> ? <t> : <t>

  <S> ::= <H> | <H> * <S>

  <A> ::= \{ <P> ; <S> \}

  <SP> ::= <A> $\leadsto$ <A>
\end{grammar}

\noindent
\begin{definition}[SuSLik Statement Equivalence]
  Given SuSLik statements $c$ and $c'$, $c \approx_S c'$ iff
    $\forall \mathcal{M}. \exists \mathcal{M'}.
      ((c, \mathcal{M}) \BigStep \mathcal{M'})
      \land
      ((c', \mathcal{M}) \BigStep \mathcal{M'})$
\end{definition}

\begin{definition}[SuSLik Specification Equivalence]
  Given SuSLik specifications $S$ and $S'$, $a \approx_{SP} a'$ iff
    $(\forall c\; c'. ((\vdash S | c) \land (\vdash S' | c')) \implies c \approx_{S} c')$
\end{definition}

\section{Translation of fun-SuSLik into SuSLik}

We give a denotational semantics for fun-SuSLik, where the denotations are SuSLik specifications, with
the function $\sem{\cdot} : \ttt{E} \ra \ttt{SP}$.
This translation is shown to preserve equivalence in two steps:

\begin{itemize}
  \item Equivalent fun-SuSLik expressions are mapped to equivalent SuSLik specifications. This amounts to proving
    \textit{full abstraction} for $\sem{\cdot}$.
  \item Non-equivalent fun-SuSLik expressions are mapped to non-equivalent SuSLik specifications.
    This is accomplished by proving $\sem{\cdot}$ is \textit{adequate}.
\end{itemize}

\noindent
More specifically, we have:

\begin{theorem}[Full Abstraction]
  If $e$ and $e'$ are fun-SuSLik expressions and $e \approx_F e'$, then $\sem{e} \approx_{SP} \sem{e'}$
\end{theorem}

\begin{theorem}[Adequacy]
  If $e$ and $e'$ are fun-SuSLik expressions and $e \not\approx_F e'$, then $\sem{e} \not\approx_{SP} \sem{e'}$
\end{theorem}





% \section{Ghost Approximation}
%
% Each subexpression will be assigned a SuSLik ghost variable. This is to specify
% that results are passed from one heaplet to another. This cannot be done directly
% through reusing memory locations across heaplets, since this is not allowed by
% separating conjunction.
%
% % The function $G : (\text{Ctx} \times \text{Expr}) \ra \text{Name}$ maps subexpressions into their corresponding ghost variable.
%
% There are three kinds of ghost variables: \verb|bool|, \verb|int| and \verb|set|. The latter
% represents sets of \verb|int|s. A lambda at the top-level of a program cannot be translated into
% SuSLik. However, lambdas are allowed at subexpressions as long as there are no redexes. Redexes will
% be $\beta$-reduced before applying the following translation.
% \\
%
% \noindent
% \textit{Preconditions for an expression to be translated into SuSLik ghost variables}:
% \begin{itemize}
%   \item No $\beta$-redexes
%   \item No nested structures, since we only have \verb|intset| ghost variables,
%     and no ghost variables which can reflect these more complicated structures. This requirement might be either lifted or relaxed later, depending on
%     if we can find a way to extend SuSLik's capabilities or a way to mitigate this limitation.\\
%     One way could be to provide SuSLik with a program
%     sketch which directly implements the passing of results from one procedure to another. In order for this to work, a SuSLik bug that limits
%     its symbolic execution capabilities must be fixed.
% \end{itemize}
%
% \noindent
% This translation is necessary, as SuSLik uses these ghost variables to specify particular computations. Note that when we translate to
% \verb|intset|s, we forget certain things about the original list (in particular, the ordering of the elements and whether there are "extra"
% elements). We will now describe this translation, and these limitations, in more detail.
%
% In effect, this restriction to \verb|intset|s \textit{requires} that we perform a kind of abstract interpretation of fun-SuSLik into the
% abstract domain of SuSLik ghost values in order to arrive at an appropriate notion of preservation of semantics when we
% translate from fun-SuSLik into SuSLik.
%
%
% \noindent
% The general pipeline of the semantics translation looks like this:
%
% \[
%   {\scriptstyle \text{Operational Semantics of fun-SuSLik} \ra \text{Approximation by SuSLik ghost values} \ra \text{Semantics of SuSLik}}
% \]
%
% First, we will define a language of SuSLik ghost types and ghost values. This will correspond to the pure part of a SuSLik specification.
%
% \textit{A note on notation}: $\mathcal{P}(X)$ is taken to mean the set of all \textit{finite} subsets of $X$. For brevity, we simply write $\mathcal{P}$ instead of 
% $\mathcal{P}_{\textnormal{fin}}$.
%
% \textbf{TODO: Should we give a syntax for sets here that differs from the typical mathematical syntax, to make the distinction more clear?}
% \\
% \begin{grammar}
%   <GT> ::= \bool | \pred | $\PZ$ | $\PPZ$
%
%   <GI> ::= ... | -1 | 0 | 1 | ...
%
%   <GB> ::= \false | \true | <GE> $\le$ <GE> | <GB> \ttt{\&\&} <GB> | <GB> \ttt{||} <GB> | \ttt{not}\; <GB>
%
%   <GS> ::= x | \{\} | <GS> \ttt{++} <GS> | <GS> \ttt{-{}-} <GS> | \{ <GL> \}
%
%   <GL> ::= <GE> | <GE> , <GL>
%
%   <GE> ::= x | <GB> | <GI> | <GE> == <GE> | <GE> + <GE> | <GE> - <GE> | <GE> * <GE> | ( <GE> ) | <GS> | \upperS\; <GS> | \lowerS\; <GS>
% \end{grammar}
%
% We will then define the translation from fun-SuSLik semantics to ghost semantics by the following 3 step process:
%
% \begin{enumerate}
%   \item Define a denotational semantics for the ghost language, $\Gsem{\cdot}$
%   \item Define a transformation $\alpha(\cdot)$ from the fun-SuSLik language of the previous section into this ghost language. We shall do this by defining a mapping of fun-SuSLik values to ghost values and a mapping from fun-SuSLik
% primitive operations into primitive ghost operations
%   \item Require that $\alpha(\cdot)$ be a homomorphism
% \end{enumerate}
%
% \subsection{Typing Judgment}
% \[
%   \begin{array}{cc}
%     \labinfer{\{i\} : \PZ}{i \in \mathbb{Z}}
%     ~~~
%     \labinfer{\true : \bool}{}
%     ~~~
%     \labinfer{\false : \bool}{}
%     ~~~
%     \labinfer{\{\} : \PPZ}{}
%     \\\\
%     \labinfer{x\; \ttt{++}\; y : \PPZ}{x : \PPZ & y : \PPZ}
%     ~~~
%     \labinfer{x\; \ttt{-{}-}\; y : \PPZ}{x : \PPZ & y : \PPZ}
%
%   \end{array}
% \]
%
% \subsection{Big-Step Operational Semantics}
%
% \textbf{TODO: Write}
%
% % \[
% %   \begin{array}{c}
% %     \labinfer{\{i\} \Downarrow \{i\}}{i \in \mathbb{Z}}
% %   \end{array}
% % \]
%
% \subsection{Translation on Types}
%
% The action of $\alpha(\cdot)$ on types is given by
%
% \[
%   \begin{array}{cc}
%     \alpha(\Int) = \PZ
%     ~~~
%     \alpha(\Bool) = \bool
%     ~~~
%     \alpha(\List\; \Int) = \PPZ
%     ~~~
%     \alpha(A \ra B) = \pred
%   \end{array}
% \]
%
% Note that $\List\; \Int$ is represented by sets of sets of integers and \textbf{nested lists are not currently supported}.
%
% \subsection{Partial Orders}
%
% We define three partial orders: one for each ghost type (other than $\pred$). For \verb|bool|, the relation
% will simply be the equality relation (the ``flat'' partial order). For \verb|int| and \verb|intset|, it will be
% the subset relation.
%
% \[
%   \begin{array}{cc}
%     \labinfer{x \boolLE x}{x : \bool}
%     ~~~
%     \labinfer{x \intLE y}{x : \intS & y : \intS & x \subseteq y}
%     % \sqsubseteq_{\intS}\; = \{ (x, x) | x : \intS \}
%     % \sqsubseteq_{\bool}\; = \{ (x, x) | x : \bool \}
%     ~~~
%     \labinfer{x \intsetLE y}{x : \intset & y : \intset & x \subseteq y}
%     % \sqsubseteq_{\intset}\; = \{ (x, y) | x : \intset, y : \intset, x \subseteq y \}
%   \end{array}
% \]
%
% \subsection{Interpreting fun-SuSLik in the Ghost Semantics}
%
% % First, we require our interpretation function, $\Gsem(\cdot)$, to respect the partial orders described in the previous
% % section. We express this as the law:
% %
% % \[
% %   \labinfer{\Gsem{e} 
% % \]
% %
% % Now, we actually define the function as follows:
%
% As not all fun-SuSLik constructs have a representation in the ghost language (the pure part),
% we use a partial function $\Gsem{\cdot} : Expr \partialfn \mathcal{G}$.
%
% \[\arraycolsep=1.4pt\def\arraystretch{1.4}
%   \begin{array}{c}
%     \Gsem{i} \ni i~~~\text{where $i \in \mathbb{Z}$}
%     \\
%     \Gsem{\True} \boolLE \true
%     \\
%     \Gsem{\False} \boolLE \false
%     \\
%     \Gsem{\nil} \intsetLE \emptyset
%     \\
%     \Gsem{\cons\; e_1\; e_2} \intsetLE \{ \Gsem{e_1} \} \cup \Gsem{e_2}
%     \\
%     \Gsem{\head\; e} \intLE \bigcup\Gsem{e}
%     \\
%     \Gsem{\tail\; e} \intsetLE \{ s \setminus x\; |\; s \in \Gsem{e}, x \in \Gsem{\head\; e}\}
%     \\
%     \Gsem{\lambda x \ra e} = \pred(x)\; \ttt{=>}\; \Gsem{e}
%     \\
%     \Gsem{(\lambda x \ra e)\; e_2} \sqle{\alpha(B)} \Gsem{e[x\mapsto e_2]}~~~\text{where $\lambda\; x \ra e : A \ra B$}
%     \\
%     \Gsem{e_1\; e_2} = \Gsem{e_1}(\Gsem{e_2})~~~\text{where $e_1$ is not a lambda}
%     % \Gsem{\foldr\; (\lambda x \ra e)\; e_0\; e_1} \in { 
%   \end{array}
% \]
%
%
%
% % ~\\\\
% % \textbf{TODO: Rewrite the following part to fit better with the preceding part}
% %
% % \noindent
% % The semantic function which translate fun-SuSLik values is given by
% % \[
% %   \Gsem{\cdot} : Expr \ra \mathcal{P}(\mathbb{Z} \uplus \mathcal{P}(\mathbb{Z}))
% % \]
% %
% % \noindent
% % Note that $\mathcal{P}(\mathbb{Z})$ is the set of all possible values of type \verb|intset|.\\
% %
% % The image of a fun-SuSLik expression in $\Gsem{\cdot}$ is the
% % set of all possible ghost values that can represent it. For example, for a fun-SuSLik list \verb|cons 1 (cons 2 (cons 3 nil))|, the possible
% % ghost values would be all \verb|intset|s that contain \ttt{1}, \ttt{2} and \ttt{3}. Compare this with the fun-SuSLik expression
% % \verb|head e|. After translating this to ghost values, all we know is that the result will be some value in the
% % list \verb|e|. By translating into sets, we've forgotten exactly which one it will be.
% %
% % We are particularly interested in minimal \textit{non-empty} elements in the image of
% % $\Gsem{\cdot}$. Again, consider the case of $\Gsem{\cons\; 1\; (\cons\; 2\; (\cons\; 3\; \nil))}$.
% % This will translate to the set of all \verb|intset| values that are supersets of $\{1,2,3\}$. However, there we notice that one
% % element of this set is most "important": the set $\{1,2,3\}$ itself. This set corresponds
% % \textit{exactly} to the elements of the original list, without containing any
% % "extra" elements.
% %
% % Also notice that, if you consider the $\subseteq$ partial order,
% % this set is a \textit{minimal} set in $\Gsem{\cons\; 1\; (\cons\; 2\; (\cons\; 3\; \nil))}$. In particular,
% % the greatest lower bound of $\Gsem{\cons\; 1\; (\cons\; 2\; (\cons\; 3\; \nil))}$ is $\{1,2,3\}$. In mathematical notation,
% % we can write:
% %
% % \[
% %   \bigcap\Gsem{\cons\; 1\; (\cons\; 2\; (\cons\; 3\; \nil))} = \{1, 2, 3\}
% % \]
% %
% % Further, note that there are cases where the greatest lower bound is just $\emptyset$. This is the case for \verb|head e|, as mentioned
% % above. To see this, observe that $\{\{1\},\{2\},\{3\}\} \subseteq \Gsem{\head\; (\cons\; 1\; (\cons\; 2\; (\cons\; 3\; \nil)))}$. Therefore,
% % we see that $\bigcap{\Gsem{\head\; (\cons\; 1\; (\cons\; 2\; (\cons\; 3\; \nil)))}} = \emptyset$.
% %
% % Thus, we are more interested in the \textit{atoms} in the image of $\Gsem{\cdot}$. An atom is any minimal element that is
% % strictly greater than the least element (the least element is $\emptyset$ in our case). Continuing our example, the atoms of $\Gsem{\head\; (\cons\; 1\; (\cons\; 2\; (\cons\; 3\; \nil)))}$ are $\{1\}$, $\{2\}$ and $\{3\}$. Furthermore, the unique atom of $\Gsem{\cons\; 1\; (\cons\; 2\; (\cons\; 3\; \nil))}$ is $\{1,2,3\}$.
% %
% % We can see that we do not just want to look at the minimal elements, we want to look at the \textit{atoms}. For this, we use the
% % following notation: Let $\Atoms X$ be the set of all atoms in $X$. Using this for our above example, we see that while the greatest lower bound
% % gives us this
% %
% % \[
% %   \bigcap\Gsem{\head\; (\cons\; 1\; (\cons\; 2\; (\cons\; 3\; \nil)))} = \emptyset
% % \]
% %
% % \noindent
% % if we instead use $\Atoms$, we get
% %
% % \[
% %   \Atoms\Gsem{\head\; (\cons\; 1\; (\cons\; 2\; (\cons\; 3\; \nil)))} = \{\{1\},\{2\},\{3\}\}
% % \]
% %
% % \noindent
% % The general list of rules for $\Gsem{\cdot}$ are given here:
% %
% % % Consider G[e] = {{1,2,3}, {1,2,3,4}, {1,2,3,4,5}, ...}
% % % and we want to find G[head e] = {{1}, {2}, {3}, ...}
% %
% % \[
% %   \begin{array}{cc}
% %     \Gsem{\nil} = \{\emptyset\}
% %     ~~~~~
% %     \Gsem{\cons\; e_1\; e_2} = \{ \Atoms\Gsem{e_1} \cup a\; |\; a \in \Atoms\Gsem{e_2} \}
% %     \\
% %     \Gsem{\head\; e} = \{ \Atoms s\; |\; s \in \Atoms\Gsem{e}\ \}
% %     ~~~~~
% %     \Gsem{\tail\; e} = \Gsem{e} \cap \Atoms\Gsem{e}
% %     % \Atoms\Gsem{\cons\; e_1\; e_2} = \{ \Atoms\Gsem{e_1} \} \cup \Atoms\Gsem{e_2}
% %   \end{array}
% % \]
% %
% %
% % \section{Translation Into SuSLik}
% %
% %
% % \noindent
% % The translation into SuSLik will be given by the semantic function $\Ssem{\cdot}$
% %
% % \noindent
% % \textbf{TODO:} Rewrite this to use the ghost variable approximation
% %
% % \[
% %   \begin{array}{cc}
% %     \Ssem{\letbnd\; x\; \ttt{:=}\; e\; \inexpr\; e_2} = x \mapsto v * \Ssem{e_2}(v) * \Ssem{e}(v)~~~\text{where $v \notin FV(\Ssem{e}) \cup FV(\Ssem{e_2})$}
% %     \\
% %     \Ssem{\lambda\; x\; \ra\; e} = \text{pred}(x) \Ra \Ssem{e}
% %     % \\
% %     % \sem{\cons\; e_1\; e_2} = \text{cons}(v
% %   \end{array}
% % \]
%

\end{document}

