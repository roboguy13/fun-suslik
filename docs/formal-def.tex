\documentclass[10pt]{article}
\usepackage{amsmath, listings, amsthm, amssymb, latexsym, proof, syntax, stmaryrd, tikz-cd}
\usepackage[T1]{fontenc}
\usepackage{scrlayer-scrpage}

\newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition}

% \renewcommand{\syntleft}{}
% \renewcommand{\syntright}{}

\newcommand{\infers}{\ensuremath{\Rightarrow}}
\newcommand{\checks}{\ensuremath{\Leftarrow}}

\newcommand{\ttt}[1]{\texttt{#1}}
\newcommand{\ra}{\ensuremath{\rightarrow}}
\newcommand{\Ra}{\ensuremath{\Rightarrow}}

\newcommand{\reduces}{\ensuremath{\longmapsto}}
\newcommand{\reducestr}{\ensuremath{\longmapsto^{*}}}

\newcommand{\BigStep}{\ensuremath{\Downarrow}}

\newcommand{\val}{\textnormal{ val}}

\newcommand{\True}{\ttt{True}}
\newcommand{\False}{\ttt{False}}
\newcommand{\head}{\ttt{head}}
\newcommand{\tail}{\ttt{tail}}
\newcommand{\cons}{\ttt{cons}}
\newcommand{\nil}{\ttt{nil}}
\newcommand{\unit}{\ttt{unit}}
\newcommand{\foldr}{\ttt{foldr}}
% \newcommand{\scanr}{\ttt{scanr}}
\newcommand{\pair}{\ttt{pair}}
\newcommand{\fst}{\ttt{fst}}
\newcommand{\snd}{\ttt{snd}}
\newcommand{\ite}{\ttt{if}}

\newcommand{\Int}{\ttt{Int}}
\newcommand{\Bool}{\ttt{Bool}}
\newcommand{\tyUnit}{\ttt{Unit}}
\newcommand{\tyPair}{\ttt{Pair}}
\newcommand{\List}{\ttt{List}}
\newcommand{\letbnd}{\ttt{let}}
\newcommand{\inexpr}{\ttt{in}}
\newcommand{\defeq}{\ttt{:=}}

\newcommand{\intS}{\ttt{int}}
\newcommand{\intset}{\ttt{intset}}
\newcommand{\bool}{\ttt{bool}}
\newcommand{\pred}{\ttt{pred}}

\newcommand{\true}{\ttt{true}}
\newcommand{\false}{\ttt{false}}

\newcommand{\upperS}{\ttt{upper}}
\newcommand{\lowerS}{\ttt{lower}}

\newcommand{\lesseq}{\ttt{le}}
\newcommand{\eq}{\ttt{eq}}

\newcommand{\labinfer} [3] [] {\infer[{\small\textsc{#1}}]{#2}{#3}}

\newcommand{\sem} [1] {\llbracket#1\rrbracket}
\newcommand{\Gsem} [1] {\mathcal{G}\sem{#1}}
\newcommand{\Ssem} [1] {\mathcal{S}\sem{#1}}
\newcommand{\Gapprox} {\approx}
\newcommand{\Atoms} {\mathcal{A}}

\newcommand{\partialfn} {\rightharpoonup}
\newcommand{\PZ} {\mathcal{P}(\mathbb{Z})}
\newcommand{\PPZ} {\mathcal{P}(\PZ)}

\newcommand{\sqle} [1] {\sqsubseteq_{#1}}
\newcommand{\boolLE} {\sqle{\bool}}
\newcommand{\intLE} {\sqle{\intS}}
\newcommand{\intsetLE} {\sqle{\intset}}

\newcommand\scalemath[2]{\scalebox{#1}{\mbox{\ensuremath{\displaystyle #2}}}}
\renewcommand{\arraystretch}{0.5}

\begin{document}

\section{Introduction}

In this document, we give a translation from fun-SuSLik to SuSLik. First, we define the syntax and
operational semantics of the two languages (Sections~\ref{sec:FSDef} and~\ref{sec:SuSLikDef}).
Then, we give definitions of equivalence in terms of these
operational semantics (Sections~\ref{sec:FSEquiv} and~\ref{sec:SuSLikEquiv}). The translation from fun-SuSLik is represented as a denotational semantics
that denotes a fun-SuSLik expression as a SuSLik specification (Section~\ref{sec:Translation}). Finally, we prove that this denotational
semantics preserves equivalence by proving adequacy and full abstraction (Section~\ref{sec:TransSoundness}).


% In this document, we describe the semantics of fun-SuSLik and translate them
% into SuSLik's semantics. Then, we translate both fun-SuSLik and SuSLik into a
% category of abstract stores and mappings between of abstract stores. An abstract store is a
% mapping from locations to values of a base type or a tuple of base types (here, the base types are \verb|int| and \verb|bool|).
% By ``location,'' we mean an abstract location: it is not represented as a number and therefore
% you cannot perform pointer arithmetic on it. We do this to avoid these extra details, which
% are not relevant to proving semantics preservation.
%
% An overview of this is given in the diagram below.
% \\
%
% \begin{tikzcd}
%   \text{fun-SuSLik} \arrow[d, "\Gsem{\cdot}"] \arrow[r, swap, "\sigma_{\mathcal{FS}}"]
%   &
%   \text{Abstract stores} \arrow[dddl, "id"]
%   \\
%   \text{Ghost approximation} \arrow[d, "\Ssem{\cdot}"]
%   \\
%   \text{SuSLik} \arrow[d, "\sigma_{\mathcal{S}}"]
%   \\
%   \text{Abstract stores}
%   % \\
%   % \text{Abstract stores}
% \end{tikzcd}
%
% ~\\
% \noindent
% We show that the translation of fun-SuSLik into SuSLik is semantics preserving by proving that this diagram commutes.
% \\
%
% \noindent
% The four categories involved are:
%
% \begin{itemize}
%   \item The fun-SuSLik category of fun-SuSLik values and fun-SuSLik functions
%   \item The ghost approximation category of SuSLik ghost values and functions between them. These ghost values are the values which are manipulated in the pure part of a SuSLik assertion
%   \item The SuSLik category of heaps and SuSLik functions
%   \item The abstract stores category of abstract stores and mappings between abstract stores
% \end{itemize}
%
%

\section{fun-SuSLik Language Definition}
\label{sec:FSDef}
\subsection{Syntax}

\begin{grammar}
  <I> ::= ... | -1 | 0 | 1 | ...

  <B> ::= \ttt{True} | \ttt{False}

  <D> ::= \ttt{x :} <T>; x <P> \ttt{:=} <e>;

  <P> ::= $\varepsilon$ | x <P>

  <e> ::= <e>$_0$ | <e> <e>$_0$

  <e$_0$> ::= <I> | <B> | \ttt{unit} | <L> | <C> | \letbnd\; x \ttt{:=} <e> \inexpr\; <e> | ( <e> )

  <L> ::= $\lambda x \ra$ <e>

  <C> ::= \head\; | \tail\; | \cons\; | \nil\; | \foldr\; | \pair\; | \fst\; | \snd\; | \ite\; | \lesseq\; | \eq

  <T> ::= \ttt{Int} | \ttt{Bool} | \ttt{Unit} | <T> $\ra$ <T> | \ttt{List} <T> | \ttt{Pair} <T> <T> | ( <T> )

  <$\Gamma$> ::= $\cdot$ | x : <T>, $\Gamma$
\end{grammar}

\subsection{Typing Judgment}

\[
  \begin{array}{c}[t]
    \infer{\Gamma \vdash x : T}{(x : T) \in \Gamma}
    ~~~
    \infer{\vdash i : \ttt{Int}}{i \in \mathbb{Z}}
    \\\\
    \infer{\vdash \ttt{unit} : \ttt{Unit}}{}
    ~~~
    \infer{\vdash \ttt{True} : \ttt{Bool}}{}
    ~~~
    \infer{\vdash \ttt{False} : \ttt{Bool}}{}
    \\\\
    \infer{\Gamma \vdash t_0\; t_1 : T'}{\Gamma \vdash t_0 : T \ra T' & \Gamma \vdash t_1 : T}
    \\\\
    \infer{\Gamma \vdash \lambda x \ra t : T \ra T'}{x : T, \Gamma \vdash t : T'}
    \\\\
    \infer{\Gamma \vdash \letbnd\; x\; \ttt{:=}\; e\; \inexpr\; e' : T'}{\Gamma \vdash e : T & x : T, \Gamma \vdash e' : T'}
    \\\\
    \infer{\vdash \ttt{nil} : \List\; T}{}
    ~~~
    \infer{\vdash \ttt{cons} : T \ra \List\; T \ra \List\; T}{}
    \\\\
    \infer{\vdash \ttt{head} : \List\; T \ra T}{}
    ~~~
    \infer{\vdash \ttt{tail} : \List\; T \ra \List\; T}{}
    \\\\
    \infer{\vdash \ttt{foldr} : (T \ra T' \ra T') \ra T' \ra \List\; T \ra T'}{}
    \\\\
    \infer{\vdash \ttt{pair} : T \ra T' \ra \tyPair\; T\; T'}{}
    ~~~
    \infer{\vdash \ttt{fst} : \tyPair\; T\; T' \ra T}{}
    ~~~
    \infer{\vdash \ttt{snd} : \tyPair\; T\; T' \ra T'}{}
    \\\\
    \infer{\vdash \ttt{ifThenElse} : \Bool \ra T \ra T \ra T}{}
    \\\\
    \infer{\vdash \ttt{le} : \Int \ra \Int \ra \Bool}{}
    ~~~
    \infer{\vdash \ttt{eq} : \Int \ra \Int \ra \Bool}{}
  \end{array}
\]

\subsection{Small-Step Operational Semantics}

First, the ``value'' judgment val (as in Harper's Practical Foundations for Programming Languages, Sec. 19.2):

\[
  \begin{array}{cc}
    \infer{i \val}{i \in \mathbb{Z}}
    ~~~
    \infer{\unit \val}{}
    ~~~
    \infer{\True \val}{}
    ~~~
    \infer{\False \val}{}
    ~~~
    \infer{\nil \val}{}
    \\\\
    \infer{\cons\; e_1\; e_2 \val}{e_1 \val & e_2 \val}
    ~~~
    \infer{\pair\; e_1\; e_2 \val}{e_1 \val & e_2 \val}
    ~~~
    \infer{\lambda x \ra e \val}{}
  \end{array}
\]

\noindent
Now the small-step reduction relation $\reduces$


\[
  \begin{array}{cc}
    \labinfer[App-1]{e_1\; e_2 \reduces e_1\; e_2'}{e_2 \reduces e_2'}
    ~~~
    \labinfer[App-2]{e_1\; e_2 \reduces e_1'\; e_2}{e_1 \reduces e_1' & e_2 \val}
    ~~~
    \labinfer[App-$\lambda$]{(\lambda x \ra e)\; e_2 \reduces e[x\mapsto e_2]}{e_2 \val}
    \\\\
    \labinfer[Let-Bnd]{\letbnd\; x\; \ttt{:=}\; e_1\; \inexpr\; e_2 \reduces \letbnd\; x\; \ttt{:=}\; e_1'\; \inexpr\; e_2}
       {e_1 \reduces e_1'}
    \\\\
    \labinfer[Let-Subst]{\letbnd\; x\; \ttt{:=}\; e_1\; \inexpr\; e_2 \reduces e_2[x\mapsto e_1]}{e_1 \val}
    \\\\
    \labinfer[Cons-1]{\cons\; e_1\; e_2 \reduces \cons\; e_1'\; e_2}{e_1 \reduces e_2}
    ~~~
    \labinfer[Cons-2]{\cons\; e_1\; e_2 \reduces \cons\; e_1\; e_2'}{e_1 \val & e_2 \reduces e_2'}
    \\\\
    \labinfer[Head-1]{\head\; e \reduces \head\; e'}{e \reduces e'}
    ~~~
    \labinfer[Tail-1]{\tail\; e \reduces \tail\; e'}{e \reduces e'}
    \\\\
    \labinfer[Head-Cons]{\head\; (\cons\; e_1\; e_2) \reduces e_1}{\cons\; e_1\; e_2 \val}
    ~~~
    \labinfer[Tail-Cons]{\tail\; (\cons\; e_1\; e_2) \reduces e_2}{\cons\; e_1\; e_2 \val}
    \\\\
    \labinfer[Pair-1]{\pair\; e_1\; e_2 \reduces \pair\; e_1'\; e_2}{e_1 \reduces e_1}
    ~~~~
    \labinfer[Pair-2]{\pair\; e_1\; e_2 \reduces \pair\; e_1\; e_2'}{e_1 \val & e_2 \reduces e_2'}
    \\\\
    \labinfer[Foldr-1]{\foldr\; f\; e_0\; e \reduces \foldr\; f'\; e_0\; e}{f \reduces f'}
    ~~~
    \labinfer[Foldr-2]{\foldr\; f\; e_0\; e \reduces \foldr\; f\; e_0'\; e}{f \val & e_0 \reduces e_0'}
    \\\\
    \labinfer[Foldr-3]{\foldr\; f\; e_0\; e \reduces \foldr\; f\; e_0\; e'}{f \val & e_0 \val & e \reduces e'}
    \\\\
    \labinfer[Foldr-Cons]{\foldr\; f\; e_0\; (\cons\; e_1\; e_2) \reduces f\; e_1\; (\foldr\; f\; e_0\; e_2)}{f \val & e_0 \val & \cons\; e_1\; e_2 \val}
    % \\\\
    % % \infer{\ttt{scanr f z $e$} \reduces \ttt{cons e$'$ (f x
    \\\\
    \labinfer[Fst-1]{\fst\; e \reduces \fst\; e'}{e \reduces e'}
    ~~~
    \labinfer[Snd-1]{\snd\; e \reduces \snd\; e'}{e \reduces e'}
    \\\\
    \labinfer[Fst-Pair]{\fst\; (\pair\; e_1\; e_2) \reduces e_1}{\pair\; e_1\; e_2 \val}
    ~~~
    \labinfer[Snd-Pair]{\snd\; (\pair\; e_1\; e_2) \reduces e_2}{\pair\; e_1\; e_2 \val}
    \\\\
    \labinfer[IfThenElse-1]{\ite\; b\; e_1\; e_2 \reduces \ite\; b'\; e_1\; e_2}{b \reduces b'}
    \\\\
    \labinfer[IfThenElse-True]{\ite\; \True\; e_1\; e_2 \reduces e_1}{}
    ~~~
    \labinfer[IfThenElse-False]{\ite\; \False\; e_1\; e_2 \reduces e_2}{}
    \\\\
    \labinfer[Le-1]{\lesseq\; e_1\; e_2 \reduces \lesseq\; e_1'\; e_2}{e_1 \reduces e_1'}
    ~~~
    \labinfer[Le-2]{\lesseq\; e_1\; e_2 \reduces \lesseq\; e_1\; e_2'}{e_1 \val & e_2 \reduces e_2'}
    \\\\
    \labinfer[Le-<]{\lesseq\; e_1\; e_2 \reduces \True}{e_1 \val & e_2 \val & e_1 < e_2}
    ~~~
    \labinfer[Le-=]{\lesseq\; e\; e \reduces \True}{e \val}
    \\\\
    \labinfer[Le-False]{\lesseq\; e_1\; e_2 \reduces \False}{e_1 \val & e_2 \val & e_1 > e_2}
    \\\\
    \labinfer[Eq-1]{\eq\; e_1\; e_2 \reduces \eq\; e_1'\; e_2}{e_1 \reduces e_1'}
    ~~~
    \labinfer[Eq-1]{\eq\; e_1\; e_2 \reduces \eq\; e_1\; e_2'}{e_1 \val & e_2 \reduces e_2'}
    \\\\
    \labinfer[Eq-True]{\eq\; e\; e \reduces \True}{e \val}
    ~~~
    \labinfer[Eq-False]{\eq\; e_1\; e_2 \reduces \False}{e_1 \val & e_2 \val & e_1 \neq e_2}

  \end{array}
\]

\noindent
Let $\reducestr$ be the transitive, reflexive closure of $\reduces$.

\begin{theorem}[Progress]
  $\forall e.\; e \val \lor (\exists e'.\; e \reduces e')$
\end{theorem}

\begin{theorem}[Preservation]
  \text{If} $e : T$ \text{and} $e \reduces e'$ \text{then} $e' : T$
\end{theorem}

\begin{theorem}[Uniqueness of Normal Forms]
  \text{If} $e : T$, $v \val$, $v' \val$, $e \reducestr v$ \text{and} $e \reducestr v'$ \text{then} $v = v'$
\end{theorem}

\subsection{Equivalence Relation}
\label{sec:FSEquiv}
We now define equivalence of fun-SuSLik programs.

\begin{definition}[Termination]
  $e$ \text{is \textnormal{terminating} iff} $\exists v.\; v \val \land e \reducestr v$.\\
  $e$ \text{is \textnormal{nonterminating} iff it is not terminating}
\end{definition}

\begin{definition}[fun-SuSLik Equivalence]
  If $e$ and $e'$ are both nonterminating, then $e \approx_F e'$.\\
  If $e$ and $e'$ are both terminating, then $e \approx_F e'$ iff $\exists v. e \reducestr v \land e' \reducestr v$\\
  Otherwise, $e$ and $e'$ are not equivalent and we write $e \not\approx_F e'$
\end{definition}

\section{SuSLik Specification Language}
\label{sec:SuSLikDef}

We define the syntax of the SuSLik specification language and then an equivalence of specifications.

\begin{grammar}
  <n> ::= 0 | 1 | ...

  <i> ::= ... | -1 | 0 | 1 | ...

  <B> ::= \true | \false

  <IS> ::= \{\} | \{ <IL> \} | <IS> -{}- <IS> | <IS> ++ <IS>

  <IL> ::= <i> | <i> , <IL>

  <H> ::= emp | x :-> <t> | [x, <n>]

  <t> ::= x | <i> | <IS> | ( <t> ) | <P> | <t> + <t> | <t> - <t> | <t> * <t>

  <P> ::= <B> | <t> == <t> | <t> $\le$ <t> | not <P> | <P> \&\& <P> | <P> $||$ <P> | <P> ? <t> : <t>

  <S> ::= <H> | <H> * <S>

  <A> ::= \{ <P> ; <S> \}

  <SP> ::= <A> $\leadsto$ <A>
\end{grammar}

\subsection{Equivalence Relation}
\label{sec:SuSLikEquiv}

\begin{definition}[Synthesizability]
  We say a specification $S$ is \textit{synthesizable} iff $\exists c. (\vdash S|c)$
\end{definition}

\begin{definition}[SuSLik Statement Equivalence]
  Given SuSLik statements $c$ and $c'$, $c \approx_S c'$ iff
    $\forall \mathcal{M}. \exists \mathcal{M'}.
      ((c, \mathcal{M}) \BigStep \mathcal{M'})
      \land
      ((c', \mathcal{M}) \BigStep \mathcal{M'})$
\end{definition}

\begin{definition}[SuSLik Specification Equivalence]
  Given synthesizable SuSLik specifications $S$ and $S'$, $S \approx_{SP} S'$ iff
    $(\forall c\; c'. ((\vdash S | c) \land (\vdash S' | c')) \implies c \approx_{S} c')$
\end{definition}

\section{Translation of fun-SuSLik into SuSLik}
\label{sec:Translation}

We give a denotational semantics for fun-SuSLik, where the denotations are SuSLik specifications, with
the function $\sem{\cdot} : \ttt{e} \ra \ttt{SP}$.
This translation is shown to preserve equivalence in two steps (Section~\ref{sec:TransSoundness}):

\begin{itemize}
  \item Equivalent fun-SuSLik expressions are mapped to equivalent SuSLik specifications. This amounts to proving
    \textit{full abstraction} for $\sem{\cdot}$.
  \item Non-equivalent fun-SuSLik expressions are mapped to non-equivalent SuSLik specifications.
    This is accomplished by proving $\sem{\cdot}$ is \textit{adequate}.
\end{itemize}

\subsection{Soundness}
\label{sec:TransSoundness}

\begin{theorem}[Full Abstraction]
  If $e$ and $e'$ are fun-SuSLik expressions and $e \approx_F e'$, then $\sem{e} \approx_{SP} \sem{e'}$
\end{theorem}

\begin{theorem}[Adequacy]
  If $e$ and $e'$ are fun-SuSLik expressions and $e \not\approx_F e'$, then $\sem{e} \not\approx_{SP} \sem{e'}$
\end{theorem}

\end{document}

