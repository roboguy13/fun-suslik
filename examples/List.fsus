%generate filterLt7 [Sll[readonly]] Sll
%generate sum [Sll[readonly]] Int
%generate constNil[Sll[readonly]] Sll
%generate car [Sll[readonly]] Int
%generate sumTailRec [Sll[readonly], Int] Int
%generate take [Sll[readonly], Int] Sll
%generate const [Sll[readonly], Sll[readonly]] Sll
%generate consFn [Int, Sll[readonly]] Sll
%generate leftList [TreeLayout[readonly]] Sll
%generate singleton [Int] Sll
%generate even [Sll[readonly]] Sll
%generate odd [Sll[readonly]] Sll
%generate maximum [Sll[readonly], Int] Int
%generate maximum2 [Sll[readonly], Int] Int
%generate append [Sll[readonly], Sll[readonly]] Sll
%generate sumLists [ListOfListsLayout[readonly]] Sll
%generate maximum_sum [ListOfListsLayout[readonly]] Int
%generate flatten [ListOfListsLayout[readonly]] Sll

data List := Nil | Cons Int List;

data Tree := Leaf | Node Int Tree Tree;

data ListOfLists := LNil | LCons List ListOfLists;

Sll : List >-> layout[x];
Sll (Nil) := emp;
Sll (Cons head tail) := x :-> head, (x+1) :-> tail, Sll tail;

TreeLayout : Tree >-> layout[x];
TreeLayout (Leaf) := emp;
TreeLayout (Node payload left right) :=
  x :-> payload,
  (x+1) :-> left,
  (x+2) :-> right,
  TreeLayout left,
  TreeLayout right;

ListOfListsLayout : ListOfLists >-> layout[x];
ListOfListsLayout (LNil) := emp;
ListOfListsLayout (LCons head tail) :=
  x :-> head, (x+1) :-> tail, ListOfListsLayout tail,
  Sll head;

sumLists : ListOfLists -> List;
sumLists (LNil) := Nil;
sumLists (LCons xs xss) := Cons (instantiate [Sll[readonly]] Int sum xs) (sumLists xss);

maximum_sum : ListOfLists -> Int;
maximum_sum xss := instantiate [Sll[mutable]] Int maximum (instantiate [ListOfListsLayout[readonly]] Sll sumLists xss);

const : List -> List -> List;
const (Nil) (Nil) := Nil;
const (Cons x xs) (Cons y ys) := Cons x xs;
const (Cons x xs) (Nil) := Cons x xs;
const (Nil) (Cons y ys) := Nil;

constNil : List -> List;
constNil (Nil) := Nil;
constNil (Cons head tail) := Nil;

consFn : Int -> List -> List;
consFn x xs := Cons x xs;

car : List -> Int;
car (Nil) := 0;
car (Cons x xs) := x;

singleton : Int -> List;
singleton x := Cons x (Nil);

filterLt7 : List -> List;
filterLt7 (Nil) := Nil;
filterLt7 (Cons head tail)
  | head < 7       := Cons head (filterLt7 tail);
  | not (head < 7) := filterLt7 tail;

leftList : Tree -> List;
leftList (Leaf) := Nil;
leftList (Node a b c) := Cons a (leftList b);

even : List -> List;
even (Nil) := Nil;
even (Cons head tail) := instantiate [Sll[readonly]] Sll odd tail;

odd : List -> List;
odd (Nil) := Nil;
odd (Cons head tail) := Cons head (instantiate [Sll[readonly]] Sll even tail);

sum : List -> Int;
sum (Nil) := 0;
sum (Cons head tail) := head + (sum tail);

sumTailRec : List -> Int -> Int;
sumTailRec (Nil) acc := acc;
sumTailRec (Cons head tail) acc := sumTailRec tail (head + acc);

replicate : Int -> Int -> List;
replicate n i
  | n == 0 := Nil;
  | not (n == 0) := Cons i (replicate (n - 1) i);

take : List -> Int -> List;
take (Nil) i := Nil;
take (Cons head tail) i
  | i == 0 := Nil;
  | not (i == 0) := Cons head (take tail (i - 1));

maximum : List -> Int -> Int;
maximum (Nil) i := i;
maximum (Cons head tail) i
  | i < head := maximum tail head;
  | not (i < head) := maximum tail i;

maximum2 : List -> Int;
maximum2 xs := instantiate [Sll[readonly], Int] Int maximum xs 0;

append : List -> List -> List;
append (Nil) ys := ys;
append (Cons x xs) ys := Cons x (append xs ys);

flatten : ListOfLists -> List;
flatten (LNil) := Nil;
flatten (LCons xs xss) := instantiate [Sll[readonly], Sll[mutable]] Sll append xs (flatten xss);

